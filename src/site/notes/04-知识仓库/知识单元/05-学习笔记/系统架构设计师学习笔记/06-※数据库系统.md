---
{"dg-publish":true,"permalink":"/04//05//06/","title":"06-※数据库系统","tags":["软考","系统架构设计师"]}
---


所属知识库：[[04-知识仓库/归纳目录/05-学习笔记/系统架构设计师学习笔记\|系统架构设计师学习笔记]]

数据库系统是系统架构设计师和系统分析师常考知识点

1. 选择案例常考数据库模式、规范化理论，并发控制，完整性，ER 图等
2. 案例部分现在也开始考察数据库分区，OSQL,反规范化，主从复制，读写分离，一致性等常用的数据库设计维护运行技术，我在本章末尾都做了补充，需要重点关注。
3. 论文考察不算太多，2020 年考过《数据分片技术及其应用》，2018 年考察过《论 NoSQL 数据库技术及其应用》，2016 年考察过《论数据访问层设计技术及其应用》，2012 年考察过《论企业应用系统的数据持久层架构设计》。

## 1 概述

## 2 ※数据库模式

数据库系统的结构可以有多种不同的层次或不同的角度，其中典型的是三级划分法，其中包括三级模式和两级映射。

### 2.1 三级模式

**外模式**：
	- 面向人群：用户（程序员和终端用户）
	- 内涵：描述组成用户试图的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件等。
	- 也称为子模式或用户模式，对应于用户级数据库。它描述用户（包括程序员和终端用户）看到或使用的那部分数据的逻辑结构，是数据库用户的数据视图，与某一应用有关的数据的逻辑表示。

**概念模式**：
	- 面向人群：数据库管理员  
	- 内涵：用以描述现实世界中的实体以及其性质与联系，定义记录、数据想、数据的完整性约束条件及记录之间的联系。
	- 也称为模式或逻辑模式，对应于概念级数据库。它是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，用以描述现实世界中的实体及其性质与联系。

**内模式**：
	- 面向人群：系统程序员  
	- 内涵：用以描述存储记录的类型、存储域的表示和存储记录的物理顺序，以及索引和存储路径等数据的存储组织。
	- 对应于物理级数据库，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。

### 2.2 三级模式之间的关系

**外模式/概念模式映射**：外模式与概念模式之间的映射。

**概念模式/内模式映射**：概念模式与内模式之间的映射。

### 2.3 两级独立性

 **物理独立性**：用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的，当数据的物理存储改变时，应用程序不需要改变。
 
**逻辑独立性**：用户的应用程序与数据库中的逻辑结构是相互独立的，当数据的逻辑结构改变时，应用程序不需要改变。

## 3 ※关系模型

### 3.1 关系模型的基本元素

**关系（表文件）**：一个二维表，由行和列组成，对应数据库中的一张表。

**元组（记录）**：表中的一行，代表一个元组或一条记录。

**属性（字段）**：表中的每一列，定义了数据的意义和数据类型。

**属性值**：行和列交叉点的值，代表特定记录的特定属性的具体数据。

**主码（主键）**：用于唯一确定表中一个元组的数据，可以是一个或多个字段。

**域**：属性的取值范围，定义了字段可以存储的数据类型和可能的值。

**关系模式**：关系的逻辑描述，一般表示为：关系名(属性 1，属性 2，…，属性 n)。

### 3.2 关系运算基础

**并（Union，`R ∪ S`）**：
- 定义：两个关系 R 和 S 的并集是由属于 R 或属于 S 或同时属于两者的所有元组组成的集合。
- 结果：包含 R 和 S 中的所有元组，但剔除重复的元组。

**差（Difference，`R - S`）**：
- 定义：关系 R 与关系 S 的差是由属于 R 但不属于 S 的所有元组组成的集合。
- 结果：包含 R 中但不在 S 中的元组。

**交（Intersection，`R ∩ S`）**：
- 定义：两个关系 R 和 S 的交集是由同时属于 R 和 S 的所有元组组成的集合。
- 结果：包含 R 和 S 中都存在的元组。

**笛卡尔积（Cartesian Product）**: 笛卡尔积是关系代数中的一个运算符，用于对两个关系（表）进行组合运算。
- 定义：如果关系 R 有 u 个元组，关系 S 有 v 个元组，那么 R 和 S 的笛卡尔积将产生 u×v 个元组。笛卡尔积的结果是一个新的关系，其中每个元组都是由 R 的一个元组和 S 的一个元组组合而成。
- 结果：笛卡尔积的结果关系包含所有可能的 R 和 S 元组的组合。

**投影（Projection，π）**：
- 定义：投影运算符用于从关系中选择指定的属性列。
- 表达式：π<属性列表>(R)，其中 R 是一个关系，属性列表是要选择的属性。可以是列号或属性名。

**选择（Selection，σ）**：
- 定义：选择运算符用于从关系中选择满足给定条件的元组。
- 表达式：σ<条件>(R)，其中 R 是一个关系，条件是一个逻辑表达式。

**连接（Join）**：
- 定义：连接运算符用于从两个关系的笛卡尔积中选取属性之间满足一定条件的元组。
- 表达式：θ连接通常表示为 R⋈<条件>S，其中 R 和 S 是两个关系，条件是一个逻辑表达式。

**自然连接（Natural Join）**：
- 定义：自然连接是特殊的θ连接，如果两个关系中进行比较的分量必须是相同的属性组，并且在结果中将重复的属性去掉。
- 表达式：通常表示为 R⋈S，其中 R 和 S 是两个关系。

### 3.3 元组演算基础

**定义**：元组演算是一种基于逻辑的查询语言，它通过逻辑表达式来描述要检索的元组。元组演算表达式通常包含原子公式和逻辑运算符。

**原子公式**：原子公式是元组演算的基本组成部分，用于描述单个元组的属性值或元组之间的关系。

**逻辑运算符**：元组演算使用逻辑运算符来组合原子公式，形成更复杂的查询表达式。主要的逻辑运算符包括：
- 存在量词（∃）：表示存在某个元组满足条件。
- 全称量词（∀）：表示所有元组都满足条件。
- 否定（￢）：表示逻辑非。
- 合取（∧）：表示逻辑与。
- 析取（∨）：表示逻辑或。

**查询表达式的形式**：元组演算的查询表达式通常形式为{t | 条件}，其中 t 表示元组，条件是一个逻辑表达式，描述元组需要满足的条件。

**应用**：元组演算为数据库查询语言提供了理论基础，QUEL 和 SQL 等查询语言的一些灵感来源于元组演算。

eg:

`R1 = {t | R(t) ∧ ￢S(t)}` 等价于 `R - S`

- **解释**：R1 是所有满足关系 R 但不满足关系 S 的元组集合。即从关系 R 中选择那些不在关系 S 中的元组。

`R2 = {t | S(t) ∧ t[3] > t[2] ∧ t[2] < 8}`

- **解释**：R2 是所有满足关系 S，并且元组的第三个属性值大于第二个属性值，且第二个属性值小于 8 的元组集合。

`R3 = {t | (∃u) (R(t) ∧ S(u) ∧ t[3] < u[2])}`

- **解释**：R3 是所有满足关系 R，并且存在一个元组 u 在关系 S 中，使得元组 t 的第三个属性值小于元组 u 的第二个属性值的元组集合。

`R4 = {t | (∀u) (R(t) ∧ S(u) ∧ t[3] > u[1])}`

- **解释**：R4 是所有满足关系 R，并且对于关系 S 中的所有元组 u，元组 t 的第三个属性值都大于元组 u 的第一个属性值的元组集合。

## 4 ※数据库设计与建模

### 4.1 数据库设计流程

**需求分析**：明确系统总体设计方案，==编写需求说明书，包括数据流图、建立的数据字典==

**概念设计**：将需求分析得到的用户需求建立抽象的信息模型（概念模型），常用 E-R 图表示，==选择局部应用、逐一设计分 E-R 图和 E-R 图合并，在此阶段==

**逻辑设计**：在概念结构设计的基础上进行数据模型设计，可以是层次模型、网状模型和关系模型，==数据模型设、E-R 图转换为关系模式、关系模式规范化、确定完整性约束、确定用户视图、反规范化设计，在此阶段==

**物理设计**：==确定数据分布、存储结构和访问方式==，存储结构要选合理的物理结构，访问方式由存储结构决定

数据库实施：根据逻辑和物理设计的结果，在计算机上建立起实际的==数据库结构==，==数据加载==、进行试运行和评价的过程

数据库运维：数据库一旦投入运行，就标志着数据库维护工作的开始，主要内容包括对数据库性能的监测和改善、故障恢复、数据库的重组和重构，在数据运行阶段，对数据库的维护主要由 DBA 完成

### 4.2 概念设计

概念设计定义：

- 概念结构：对现实世界的抽象，建立抽象的信息模型（概念模型）。
- 概念模型：现实世界的模型，易与不熟悉计算机的用户交流，是整个数据库设计的关键。

常用策略：==使用自顶向下方法进行需求分析。使用自底向上方法设计概念结构==。

设计步骤：

- **选择局部应用**：确定局部视图的范围。
- **逐一设计分 E-R 图**：识别实体及其标识，确定实体之间的联系，分配实体及联系的属性。
- **E-R 图合并**：将各个局部 E-R 图合并成一个系统的总体 E-R 图。

E-R 图的基本要素：

- **实体（型）**：用矩形框表示，框内标注实体名称。
- **属性**：单值属性用椭圆形表示，多值属性用双实线椭圆表示，派生属性用虚线椭圆表示。
- **联系**：用菱形框表示，框内标注联系名称，并用连线将菱形框分别与有关实体相连，并在连线上注明联系类型（1:1、1:n 或 m:n）。

E-R 图联系：

- **一对一联系（1:1）**：A 中的每个实体至多和 B 中的一个实体有联系，反过来，B 中的每个实体至多和 A 中的一个实体有联系。
- **一对多联系（1:n）**：A 中的每个实体可以和 B 中的几个实体有联系，而 B 中的每个实体至少和 A 中的一个实体有联系。
- **多对多联系（m:n）**：A 中的每个实体可与 B 中的多个实体有联系，反过来，B 中的每个实体也可以与 A 中的多个实体有联系。

整体 E-R 图设计：

- **合并**：确定各个局部 E-R 图的公共实体类型，以公共实体类型为单位合并，直到所有相同的实体类型都被合并，得到全局 E-R 图。
- **消除冲突**：
	- ==属性冲突==：包括属性域冲突和属性取值冲突。
	- ==命名冲突==：包括同名异义和异名同义。
	- ==结构冲突==：同一对象在不同应用中具有不同的抽象；同一实体在不同局部 E-R 图中包含的属性个数或属性排列次序不完全相同；实体之间的联系在局部 E-R 图中呈现不同的联系类型。
- **消除冗余**：冗余分为冗余属性和冗余联系，通过分析方法消除冗余。
	- ==冗余属性：属性之间存在函数依赖关系==。
	- ==冗余联系：联系之间存在传递依赖关系==。

E-R 图联系类型：

- **弱实体**：依赖于某个实体而存在的实体。
- **弱关系**：与弱实体一起使用的联系。
- **不完全概化**：父实体的实例可以是子实体的实例，也可以不是任何子实体的实例。
- **完全概化**：父实体的所有实例必须是某个子实体的实例。

Armstrong 公理系统：

- **自反性**：若 X⊇Y，则存在 X → Y。
- **增广性**：若 X → Y，则存在 XZ → YZ。
- **传递性**：若 X → Y 和 Y → Z，则存在 X → Z。
- **合并性**：若 X → Y 和 X → Z，则存在 X → YZ。
- **分解性**：若 X → Y，且 Y⊇Z，则存在 X → Z。
- **伪传递性**：若 X → Y 和 WY → Z，则存在 WX → Z。
- **复合性**：若 X → Y 和 Z → W，则存在 XZ → YW。
- **自增性**：若 X → Y，则存在 XW → YW。

### 4.3 逻辑设计

E-R 图转换关系模式：

- **转换方法**：将 E-R 图中的属性、实体及实体之间的联系转换为关系模式。
- **一对一联系**：可以转换为一个独立的关系模式，也可以与任意一端实体所对应的关系模式合并。
- **一对多联系**：可以转换为一个独立的关系模式，也可以与 n 端实体所对应的关系模式合并。
- **多对多联系**：可以转换为一个独立的关系模式，关系的属性由与该联系相连的各实体的主码以及联系本身的属性转换而来。

函数依赖：

- **定义**：一个属性或属性集决定另一个属性或属性集。
- **类型**：平凡函数依赖、非平凡函数依赖、完全函数依赖、部分函数依赖、传递函数依赖。
- **例子**：职工关系（职工号，姓名，性别，年龄，职务），其中职工号函数决定姓名。

无损联接分解：

- **定义**：分解后的关系通过自然连接可以恢复成原来的关系。
- **判定定理**：如果分解后的关系通过自然连接可以恢复成原来的关系，则称分解是无损联接分解。
- **快速判定**：设 R 为关系模式，R1 和 R2 为 R 的两个属性集，F 是 R 上的函数依赖集，那么分解是无损联接分解的充要条件是 R1 ∩ R2 → R1-R2 或 R1 ∩ R2 → R2-R1。

保持函数依赖：分解之后的函数依赖的集合合并起来，与原来的函数依赖集合是保持等价的。

规范化意义：

- **存储异常**：数据冗余、修改异常、插入异常、删除异常。
- **范式**：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、BCNF、第四范式（4NF）。

键/码/属性：

- **主键/码**：用来区分不同实体的候选码。
- **超码**：一个或多个属性的集合，可以唯一标识一个实体。
- **候选码**：超码的真子集，不能包括超码。==根据依赖关系画出有向图，候选码是没有入度的属性集，且可以通过有向图找到所有的顶点。==
- **主属性**：包含在任一候选码中的属性。
- **非主属性**：不包含在任一候选码中的属性。

五大范式：

- **第一范式（1NF）**：所有属性只包含原子值。
- **第二范式（2NF）**：不存在非主属性对候选码的部分函数依赖。
- **第三范式（3NF）**：不存在非主属性对候选码的传递函数依赖。
- **BCNF*：不存在任何属性对候选码的传递函数依赖。
- **第四范式（4NF）**：针对有多值依赖的关系模型所定义的规范化形式。

## 5 ※数据库的控制功能

**并发控制**：
- 负责协调多个事务同时对同一数据进行操作，确保数据库的完整性不受破坏，避免用户得到不正确的数据。
- 包括事务的概念、锁的概念、并发问题及其解决方案。

**性能优化**：
- 通过反规范化、索引优化、冷热数据分离等手段提高数据库的查询和操作性能。
- 包括硬件升级、数据库设计、检索策略和查询优化等方面的优化措施。

**数据完整性和安全性**：
- 通过定义和实施完整性约束条件，确保数据库中的数据符合预定义的规则，防止数据错误。
- 包括实体完整性、参照完整性、触发器等机制。
- 保护数据库免受未授权访问和攻击，确保数据的机密性和完整性。
- 包括用户权限管理、数据加密、审计日志等措施。

**数据备份与恢复**：
- 定期备份数据库数据，以便在发生故障时能够快速恢复数据，减少数据丢失的风险。
- 包括物理备份、逻辑备份、完全备份、增量备份和差异备份等备份策略。

这些控制功能虽然看似边缘性技术，但对数据库管理系统的应用而言，却是至关重要的。

### 5.1 ※并发控制

**定义**：在多用户共享系统中，许多事务可能同时对同一数据进行操作，称为并发操作。DBMS 的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，同时避免用户得到不正确的数据。

#### 5.1.1 事务的基本概念

**事务的定义**：事务是数据库的逻辑工作单位，是用户定义的一个数据库操作序列，这些操作序列要么全做，要么全不做，是一个不可分割的工作单位。

**事务的特性**：
- *原子性 (Atomicity)*：事务包含的一组更新操作是原子不可分的，即这些操作是一个整体，不能部分地完成。
- *一致性 (Consistency)*：事务使数据库从一个一致性状态变到另一个一致性状态。例如，转账操作中，各账户金额必须平衡。
- *隔离性 (Isolation)*：事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- *持久性 (Durability)*：事务一旦提交，改变就是永久性的，无论发生何种故障，都不应该对其有任何影响。

#### 5.1.2 数据一致性问题

**数据不一致问题**：数据库的并发操作会带来一些数据不一致问题，例如丢失修改、读"脏数据"和不可重复读等。

**具体问题**：
- *丢失修改*：事务 A 与事务 B 同时对同一数据进行修改，事务 B 的提交结果破坏了事务 A 提交的结果，导致事务 A 的修改被丢失。
- *读"脏数据"*：事务 A 修改数据后写回磁盘，事务 B 读取同一数据后，事务 A 由于某种原因被撤销，导致事务 B 读到的数据与数据库中的数据不一致。
- *不可重复读*：事务 A 读取数据后，事务 B 执行了更新操作，事务 A 再次读取数据时，发现数据已经改变，导致数据不一致。
- *幻读*：事务 A 读取某个范围的数据，事务 B 在这个范围内插入新的数据，事务 A 再次读取这个范围的数据时，发现读取结果与第一次不同。

#### 5.1.3 封锁技术

**定义**：处理并发控制的主要方法是采用封锁技术，主要有两种封锁，分别是 X 封锁和 S 封锁。

**封锁类型**：
- *排他型封锁 (X 封锁)*：事务 T 对数据对象 A 实现 X 封锁后，只允许事务 T 读取和修改数据 A，其他事务要等事务 T 解除 X 封锁后才能对数据 A 实现任何类型的封锁。
- *共享型封锁 (S 封锁)*：事务 T 对数据 A 实现 S 封锁后，允许事务 T 读取数据 A，但不能修改数据 A，在所有 S 封锁解除之前，决不允许任何事务对数据 A 实现 X 封锁。

**封锁协议**：
- *一级封锁协议*：防止丢失修改，但不能保证可重复读和不读"脏数据"。
- *二级封锁协议*：防止丢失修改和读"脏数据"，但不能保证可重复读。
- *三级封锁协议*：防止丢失修改、读"脏数据"，且能保证可重复读。
- *两段锁协议*：所有事务必须分两个阶段对数据项加锁和解锁，保证事务的并发调度策略是可串行化的。

封锁粒度小则并发性高，但开销大；封锁粒度大则并发性低但开销小，综合平衡照顾不同需求，以合理选取适当的封锁粒度是很重要的

#### 5.1.4 MySQL 事务隔离级

**定义**：MySQL 中的事务隔离级别是为了解决脏读、不可重复读和幻读等问题。

**隔离级别**：
- **读取未提交 (READ-UNCOMMITTED)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读。
- **读取已提交 (READ-COMMITTED)**：允许读取并发事务已经提交的数据，可以阻止脏读，但幻读或不可重复读仍有可能发生。
- **可重复读 (REPEATABLE-READ)**：对同一字段的多次读取结果都是一致的，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- **可串行化 (SERIALIZABLE)**：最高的隔离级别，所有的事务依次逐个执行，杜绝了脏读、不可重复读和幻读。

总结表格  

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |     实现机制     |
|:----------------:|:----:|:----------:|:----:|:----------------:|
| READ-UNCOMMITTED | 可能 |    可能    | 可能 |        无        |
|  READ-COMMITTED  | 不会 |    可能    | 可能 | 读取已提交的数据 |
| REPEATABLE-READ  | 不会 |    不会    | 可能 |     可重复读     |
|   SERIALIZABLE   | 不会 |    不会    | 不会 |    串行化执行    |

### 5.2 数据库性能优化

**定义**：数据库性能优化涉及通过各种手段提高数据库的查询和操作性能，确保系统能够高效地处理大量数据和高并发请求。

#### 5.2.1 反规范化

**定义**：反规范化是通过增加冗余属性来减少关系模式之间的复杂连接操作，从而提高系统性能。

**常用措施**：
- *存储常用计算属性*：将常用的计算属性（如总计和最大值等）存储到数据库实体中。
- *重新定义实体*：减少外部属性数据或行数据的开支。
- *水平或垂直分割关系*：提升并行访问度。

**优点**：减少连接操作，提高查询性能。

**缺点**：增加数据冗余，可能导致更新异常、插入异常和删除异常。

#### 5.2.2 索引优化

**定义**：索引是提高数据库查询速度的利器，通过合理建立和选择索引，可以显著提高数据库性能。

**建立与选择索引的准则**：
- *选择经常查询的属性*：建立索引时应选用经常作为查询条件的属性，避免对经常更新的属性建立索引。
- *限制索引数量*：一个关系上的索引过多会影响更新、插入和删除的性能。
- *分析查询频度*：找出使用最多的索引，先对这些索引进行优化。
- *小关系不建索引*：对于数据量非常小的关系不必建立索引，因为关系扫描往往更快。

#### 5.2.3 冷热数据分离

**定义**：根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，分别存储在不同的存储介质中。

**优点**：优化热数据的查询性能，节约存储成本。

**缺点**：增加系统复杂性和风险，统计效率低。

冷数据迁移方案：

- 业务层代码实现：在写操作时触发冷热分离逻辑。
- 任务调度：利用分布式任务调度平台定时扫描数据库，找出满足冷数据条件的数据进行迁移。
- 监听数据库变更日志：从变更日志中提取满足冷数据条件的数据进行迁移。

### 5.3 ※完整性约束

**定义**：数据库完整性约束用于确保数据库中的数据符合预定义的规则，防止数据错误和不一致。

#### 5.3.1 完整性约束条件

**定义**：完整性检查是对数据库中的数据设置约束条件，确保数据符合预定义的规则。

**分类**：
- **静态约束**：对数据库中数据本身的限制，如数据类型、取值范围等。
- **动态约束**：对数据库中数据变化的限制，如订单金额不能为负数。

**功能**：
- **定义功能**：用于定义完整性约束条件。
- **检查功能**：用于检查用户操作是否违反了完整性约束条件。

#### 5.3.2 实体完整性

**定义**：实体完整性规则是指关系的主属性（主键）的组成不能为空。

**例子**：对于学生关系 S(Sno, Sname, Sex)，其主键为 Sno，在插入某个元组时，必须要求 Sno 不能为空。

#### 5.3.3 参照完整性

**定义**：参照完整性要求关系中的外键值必须是被参照关系中某个元组的主键值，或者为空值。

**例子**：对于学生关系 S(Sno, Sname, Sex)和选课关系 C(Sno, Cno, Grade)，C 中的 Sno 是外键，它是 S 的主键，若 C 中出现了某个 S 中没有的 Sno，即某个学生还没有注册，却已有了选课记录，这显然是不合理的。

**删除问题**：
- **级联删除**：将参照关系中所有外键值与被参照关系中要删除元组主键值相同的元组一起删除。
- **受限删除**：仅当参照关系中没有任何元组的外键值与被参照关系中要删除元组的主键值相同时，系统才可以执行删除操作。
- **置空删除**：删除被参照关系的元组，并将参照关系中相应元组的外键值置为空值。

**插入问题**:
- **受限插入**：仅当参照关系中有元组的外键值与被参照关系中要插入元组的主键值相同时，系统才可以执行插入操作。
- **递归插入**：在插入被参照关系的元组时，系统自动在参照关系中插入相应的元组。

#### 5.3.4 触发器

**定义**：触发器是一个数据库对象，当指定数据操作语言操作发生时，该对象可以自动执行一个或多个 SQL 语句。

**功能**：可以在一个表上定义一个或多个触发器以便在 SELECT、INSERT、UPDATE 或 DELETE 触发事件发生之后进行操作。

**例子**：当某个表的数据被更新时，可以自动执行一些特定的操作，如发送通知、更新其他表的数据等。

### 5.4 ※数据备份与恢复

**定义**：备份与恢复技术用于保护数据库中的数据，确保在发生故障时能够快速恢复数据，减少数据丢失的风险。

**策略**：
- **完全备份**：备份整个数据库中的数据。
- **增量备份**：备份上一次备份后发生变化的数据。
- **差异备份**：备份上一次完全备份后发生变化的所有数据。

**备份周期**：一个备份周期通常由一个完全备份和多个增量、差异备份组成，以提高备份和恢复的效率。

#### 5.4.1 ※物理备份

**定义**：物理备份是在操作系统层面上对数据库的数据文件进行备份，分为冷备份和热备份。

**冷备份**：
- **定义**：在数据库停止状态下，将数据库的文件全部备份（复制）下来。
- **优点**：备份速度快，容易归档，容易恢复到某时间点，能与归档方法结合做到最佳状态恢复，低维护度，高度安全。
- **缺点**：单独使用只能提供到某一时间点的恢复，备份过程中数据库不可用，不能按表或按用户恢复，需要用到外部存储设备，速度会很慢。

**热备份**：
- **定义**：在数据库正常运行的状态下，将数据库中的数据文件备份出来。
- **优点**：可以表空间或数据库文件级别备份，备份时间短，备份时数据库仍可使用，恢复速度快，可以对所有实体做恢复。
- **缺点**：操作复杂，维护困难。

#### 5.4.2 ※逻辑备份

**定义**：逻辑备份是利用 DBMS 自带的工具软件备份和恢复数据库的内容，如 Oracle 的 exp 和 imp 工具，MySQL 的 mysqldump 和 mysqlimport 工具。

**优点**：简单方便，适用于数据量不大的情况。

**缺点**：随着数据量的增大，恢复速度慢。

#### 5.4.3 ※数据恢复

**定义**：数据恢复是指将备份的数据恢复到数据库中，确保数据的一致性和完整性。

**日志文件**：
- **undo log**：用于事务回滚和 MVCC，逆向扫描日志。保证事务的原子性。
- **redo log**：用于故障恢复，确保事务的持久性，正向扫描日志。
- **bin log**：记录所有数据库表结构变更和表数据修改的日志，用于数据备份和主从复制。

## 6 数据库仓库技术

**定义**：数据仓库技术用于支持复杂的分析操作，侧重决策支持，提供直观易懂的查询结果。

*OLTP*：Online Transaction Processing，面向事务处理，主要用于日常的数据库操作，如增删改查等。

*OLAP*：Online Analytical Processing，面向分析处理，主要用于复杂的查询和分析操作。

*OLTP vs. OLAP*:
- 用户：OLTP 面向操作人员和低层管理人员，OLAP 面向决策人员和高层管理人员。
- 功能：OLTP 用于日常操作，OLAP 用于决策支持。
- DB 设计：OLTP 面向应用，OLAP 面向主题。
- 数据：OLTP 用于当前数据，OLAP 用于历史数据。
- 存取：OLTP 数十条记录，OLAP 数百万条记录。
- 工作单位：OLTP 事务，OLAP 查询。
- 用户数：OLTP 数千用户，OLAP 数十用户。
- 数据库大小：OLTP GB 级，OLAP TB 级。

**多维分析**：多维分析是 OLAP 的基本操作，通过钻取、切片和切块、旋转等方式对数据进行深入分析。

**操作**：
- **钻取 (Drill)**：改变维的层次，变换分析的粒度，包括向上钻取 (Roll Up) 和向下钻取 (Drill Down)。
- **切片和切块 (Slice and Dice)**：在部分维上选定值后，关心度量数据在剩余维上的分布。
- **旋转 (Pivot)**：变换维的方向，重新安排维的放置。

## 7 分布式数据库系统

**定义**：分布式数据库系统使用较小的计算机系统通过网络互相连接，共同组成一个完整的、全局的大型数据库。

**特点**：
- **数据独立性**：包括数据的逻辑独立性与物理独立性，以及数据分布独立性（分布透明性）。
- **集中与自治共享结合的控制结构**：各局部的 DBMS 可以独立管理局部数据库，同时系统又设有集中控制机制。
- **适当增加数据冗余度**：提高系统的可靠性和可用性。
- **全局的一致性、可串行性和可恢复性**：确保数据在任何事务执行后都保持合法状态。

**结构层次**：
- **全局外模式**：用户看到的数据展示。
- **全局概念模式**：定义了整个分布式数据库的逻辑结构。
- **分片模式**：将一个关系模式分解成数据片段的方式。
- **分布模式**：定义数据片段在不同物理位置的存储方式。
- **局部概念模式**：局部数据库的概念模式，描述了局部数据的逻辑结构。
- **局部内模式**：局部数据库的内部结构，包括存储和索引方式等。

### ※ 数据分片 (分库)

**定义**：数据分片将数据库整体逻辑结构分解为合适的逻辑单位（片段），然后由分布模式来定义片段及其副本在各场地的物理分布。

**分类**：
- **水平分片**：将一个全局关系中的元组分裂成多个子集。
- **垂直分片**：将一个全局关系按属性分裂成多个子集。
- **导出分片**：水平分片的条件不是本关系属性的条件，而是其他关系属性的条件。
- **混合分片**：采用水平分片和垂直分片两种形式的混合。

**原则**：
- **完整性**：全局关系的所有数据都必须分配到各个片段中。
- **重构性**：各个片段可以重构原来的全局关系。
- **不相交性**：全局关系中的每个元组仅属于一个片段。

### 分布透明性

**定义**：分布透明性是指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。

**分类**：
- **分片透明性**：用户或应用程序只对全局关系进行操作而不必考虑数据的分片。
- **位置透明性**：用户或应用程序应当了解分片情况，但不必了解片段的存储场地。
- **局部数据模型透明性**：用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。

## 8 分布式事务

**定义**：分布式事务用于处理跨多个节点的事务，确保事务的原子性、一致性、隔离性和持久性。

### 8.1 CAP 理论

**定义**：CAP 理论是指计算机分布式系统的三个核心特性：一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)。

**数据一致性 (Consistency)**：数据一致性指的是多个节点上的数据副本必须保持一致。

**可用性 (Availability)**：可用性要求系统内的节点们接收到了无论是写请求还是读请求，都要能处理并给回响应结果。

**分区容错性 (Partition tolerance)**：分区容错性是指系统必须能够容忍分布式系统中的某些节点或网络分区出现故障或延迟。

### 8.2 ※分布式系统实现

**定义**：分布式系统实现涉及根据 CAP 理论选择合适的一致性和可用性策略。

**组合方式**：
- **一致性和分区容忍性 (CP)**：在网络分区期间，某些操作可能不可用，牺牲了可用性。
- **可用性和分区容忍性 (AP)**：在网络分区期间，不同节点可能有不同的数据副本，导致数据不一致。
- **一致性和可用性 (CA)**：无法在分布式环境下实现。

**CP 系统**：CP 结构选择了一致性和分区容错性。如果选择一致性（C），为了保证数据库的一致性，必须等待失去联系的节点恢复过来。在这个过程中，那个节点是不允许对外提供服务的，系统处于不可用状态（失去了 A）。Zookeeper 是一个典型的例子，当客户端心跳消失时，Zookeeper 会很快剔除该服务，之后就无法提供需求。

**AP 系统**：AP 结构选择了高可用和分区容错性。即使失去联系的节点依然可以向系统提供服务，但它的数据不能保证是同步的（失去了 C 属性）。Eureka 是一个 AP 架构的例子，当 Eureka 客户端心跳消失时，Eureka 服务端会启动自我保护机制，不会剔除该 EurekaClient 客户端的服务，依然可以提供需求。

### 8.3 ※BASE 理论

**定义**：BASE 理论是对 CAP 理论的延伸，是指 Basically Available、Soft state、Eventually consistent。BASE 理论的基本思路是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致性状态。

**基本可用（Base Available）** 指的是分布式系统在出现不可预知故障时，允许损失部分可用性。

**软状态（Soft State）** 也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。

**最终一致性（Eventually Consistent）** 指的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

### 8.4 分布式事务理论解决方案

**分布式事务定义**：
- 分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
- 例如在大型电商系统中，下单接口通常会涉及扣减库存、减去优惠、生成订单 id，而订单服务与库存、优惠、订单 id 是不同的服务，下单接口的成功与否，不仅取决于本地的 db，而且依赖第三方系统的结果。

**刚性事务 2PC (Two-Phase Commit)**：
- **阶段一：事务预处理/投票阶段**
		- 事务询问：协调者向所有参与者发送事务内容，询问是否可以执行提交操作，并开始等待各参与者进行响应。
		- 执行事务：各参与者节点执行事务操作，并将 Undo 和 Redo 操作计入本机事务日志。
		- 反馈事务问询的响应：各参与者向协调者反馈事务问询的响应，成功执行返回 Yes，否则返回 No。
- **阶段二：提交阶段/执行阶段**
		- 执行事务提交：所有参与者 Reply Yes，协调者向所有参与者发送 Commit 请求，参与者正式执行事务提交操作，并在完成提交操作后释放资源。
		- 中断事务：存在某一参与者向协调者发送 No 响应或等待超时，协调者向所有参与者发送 Rollback 请求，参与者执行回滚操作并释放资源。
- **2PC 优点**：实现原理简单。
- **2PC 缺点**：
		- 性能问题：所有参与事务操作的逻辑都处于阻塞状态，占用系统资源。
		- 单点故障：协调者是个单点，一旦出现问题，其他参与者将无法释放事务资源。
		- 数据不一致：执行事务提交过程中，协调者向所有参与者发送 Commit 请求后，如果发生局部网络异常或协调者自身崩溃，可能只有部分参与者收到并执行了请求，导致数据不一致。
		- 保守机制：2PC 没有完善的容错机制，一旦出现问题，协调者无法快速得知，只能等待超时，导致性能下降。无法应对动态的网络环境

**柔性事务 TCC (Try-Confirm-Cancel)**：
- **Try 阶段**：尝试执行，完成所有业务检查（一致性），预留必须业务资源（准隔离性）。
- **Confirm 阶段**：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，要求具备幂等设计。
- **Cancel 阶段**：取消执行，释放 Try 阶段预留的业务资源，Cancel 操作满足幂等性。
- **优点**：
		- 解决了协调者单点问题，由主业务方发起并完成业务活动。
		- 引入超时，超时后进行补偿，不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
		- 有了补偿机制之后，由业务活动管理器控制一致性。
- **缺点**：代码实现复杂度相对较高。

> 在 Try 阶段，是对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try 阶段操作是对这个可用库存数量进行操作。

**柔性事务本地消息表**：
- **设计核心**：将需要分布式处理的任务通过消息的方式来异步确保执行，通过在本地数据库中记录消息的发送状态，结合异步消息队列，实现事务的最终一致性。
- 发送消息方：有一个消息表记录消息状态相关信息，业务数据和消息表在同一个数据库，保证在同一个本地事务中处理。
- 消息消费方：处理消息队列中的消息，完成自己的业务逻辑。如果本地事务处理成功，则表明已经处理成功；如果本地事务处理失败，则重试执行。
- **优点**：实现逻辑简单，开发成本较低。
- **缺点**：与业务场景绑定，高耦合，占用业务系统资源，量大可能会影响数据库性能，消息异步发送和处理可能会引入延迟。

## 9 ※Mysql 读写分离和主从复制

**读写分离适用场景**：
- 主要用于将对数据库的读写操作分散到不同的数据库节点上，提升写性能，大幅提升读性能。
- 一般选择一主多从架构，即一台主数据库负责写，其他从数据库负责读。

**读写分离一致性问题**：
- *主从同步延迟*：主库和从库的数据同步存在延迟，导致主库和从库的数据不一致性问题。
- 解决方法：
		- *半同步复制*：主库在提交事务后，等待至少一个从库接收并写入事务的二进制日志到中继日志中。优点是简单，缺点是会牺牲主库的性能。
		- *数据库中间件*：读写都通过数据库中间件，写请求路由到主库，读请求路由到从库。优点是能保证绝对一致，缺点是高成本。
		- *缓存记录*：在应用层使用缓存记录写操作的 key，并在主从同步时间窗口内将读请求路由到主库。优点是成本低，缺点是需要引入额外的缓存操作。

**主从复制**：
- 主库将数据库中数据的变化写入到二进制日志。
- 从库连接主库，并请求复制。
- 从库创建一个 I/O 线程向主库请求更新的二进制日志。
- 主库创建一个二进制日志 dump 线程来发送二进制日志，从库中的 I/O 线程负责接收。
- 从库的 I/O 线程将接收的二进制日志写入到中继日志中。
- 从库的 SQL 线程从中继日志中读取事件并应用到本地数据库中。
- **优势**：
	- *数据冗余*：提供数据的副本，以防主库故障。
	- *负载均衡*：将读操作分流到从库，减轻主库的负载。
		- *高可用性*：主库故障时，可以快速切换到从库。
		- *数据恢复*：从库可以用于恢复主库上的已丢失数据。

## 10 ※MySQL 分区技术与分片技术

**数据分片**：
- **定义**：数据分片是将数据库横向扩展到多个物理节点上的方法，目的是突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。
- **分片算法**：
		- *哈希分片*：根据指定 key 的哈希值确定数据应被放置在哪个表中，适合随机读写场景。
		- *范围分片*：按特定范围区间分配数据，适合需要经常进行范围查找的场景。
		- *地理位置分片*：根据地理位置分配数据。
		- *融合算法*：灵活组合多种分片算法。
- **数据库中间件**：
		- *MyCat*：==流行的基于 Java 的数据库中间件，实现 MySQL 协议，支持分库分表。==MyCat 是目前最流行的基于 Java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 DBC 协议与大多数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分离。
		- *ShardingSphere*：==分布式数据库生态系统，将任意数据库转换为分布式数据库，支持数据分片、弹性伸缩等。==ShardingSphere 是一款分布式的数据库生态系统，可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强。设计哲学为 Database Plus,旨在构建异构数据库上层的标准和生态。

**数据分区**：
- **定义**：MySQL 分区是将一张表的数据按某种规则划分为多个逻辑子集，每个分区存储特定范围或条件的数据。
- **分区类型**：
		- **范围分区**：按连续范围（如日期或数字）对数据进行分区。
		- **列表分区**：按离散值列表（如枚举类型）对数据进行分区。
		- **哈希分区**：按哈希值对数据进行分区。
		- **复合分区**：组合使用多种分区类型。
- **分区命名格式**：分区文件命名方式为表名.分区名.数据文件扩展名。

**分片与分区的差别**：
- **粒度**：分区是逻辑上的划分，分片是物理上的划分。
- **范围**：分区通常在单个数据库实例内，分片可以跨多个数据库实例或服务器。
- **目的**：分区优化查询性能，分片提高可扩展性和并发性。
- **实现方式**：分区使用 `PARTITION BY` 子句，分片使用多个物理表。
- **管理难度**：分区相对简单，分片相对复杂。

**分区配置管理方法**：
- **创建分区表**：使用 `CREATE TABLE` 语句和 `PARTITION BY` 子句指定分区函数。
- **添加分区**：使用 `ALTER TABLE` 语句添加新的分区。
- eg:
	- `Create table table_name (id int, name varchar(20), age int) PARTITION BY RANGE (id) (PARTITION p0 VALUES LESS THAN (10), PARTITION p1 VALUES LESS THAN (20));`
	- `ALTER TABLE table_name ADD PARTITION (PARTITION partition_name VALUES LESS THAN (value));`

**分表配置管理方法**：
- **创建多个物理表**：使用 `CREATE TABLE` 语句创建多个物理表。
- **使用分表规则**：应用程序或中间件根据分表规则将数据路由到不同的分表。
- **管理分表**：需要手动创建、删除和维护分表。
- eg:
	- `Create table table_name_0 (id int, name varchar(20), age int);`
	- `Create table table_name_1 (id int, name varchar(20), age int);`

## 11 ※NOSQL 技术

NoSQL（Not Only SQL 或非 SQL）是一种数据库设计方法，用于在关系数据库的传统结构之外存储和查询数据。以下是对 NoSQL 数据库的简要介绍：

**定义**：
- NoSQL 数据库不使用关系数据库的典型表结构，而是将数据存储在非关系数据结构中，如 JSON 文档。
- NoSQL 数据库是一种分布式数据库类型，将信息复制并存储在不同的服务器上，确保数据的可用性和可靠性。

**优势**：
- **可扩展性**：轻松扩展到处理海量数据。
- **高并发性**：处理大量并发请求，适合实时数据和高流量应用程序。
- **灵活性**：提供灵活的数据模型，适应不断变化的数据需求。
- **高可用性**：通常具有高可用性，提供冗余和故障转移功能。

**劣势**：
- **数据一致性**：通常提供最终一致性而非强一致性，可能导致数据不一致。
- **事务处理**：通常不提供事务支持，跨多个操作维护数据完整性困难。
- **查询功能**：查询功能不如关系数据库强大，可能限制复杂查询和数据分析。
- **数据建模**：需要不同的建模技术，可能需要学习成本。

**应用场景**：
- **大数据处理**：处理海量数据，性能优于关系数据库。
- **并发性**：在高并发环境下表现优越，避免瓶颈。
- **数据灵活性**：提供更灵活的数据模型，适应快速变化的需求。
- **成本**：通常比关系数据库更具成本效益，运行在廉价硬件上，无需昂贵许可证。

**NoSQL 数据库类型**：
- **键值数据库**：使用简单的键值方法来存储数据。键作为唯一标识符，值可以是任何类型的对象。使用键值对存储数据，查找速度快，但数据无结构化。键值对存储，通常使用哈希表实现。
- **列存储数据库**：将同一个数据列的各个值存放在一起。适用于大数据量查询。以列簇式存储，适合大数据量查询，但功能相对局限。
- **文档型数据库**：以文档为单位存储和管理数据，通常使用 JSON、BSON 或 XML 格式。存储结构化文档，数据结构要求不严格，但查询性能不高。键值对，值为结构化数据。
- **图形数据库**：专门用于存储和查询图结构数据，包括节点和节点之间的关系。专注于构建关系图谱，利用图结构算法，但计算量大且不易分布式。图结构，包括节点和边。

| 数据库类型   | 优点                         | 缺点                                        | 适用场景                       | 典型产品         |
| ------------ | ---------------------------- | ------------------------------------------- | ------------------------------ | ---------------- |
| 键值数据库   | 查找速度快、高可分区性       | 数据无结构化,通常只被当作字符串或二进制数据 | 内容缓存、日志系统             | Redis            |
| 列存储数据库 | 查找速度快、可扩展性强       | 功能相对局限                                | 分布式文件系统、物联网数据存储 | Cassandra、HBase |
| 文档型数据库 | 数据结构要求不严格、灵活性高 | 查询性能不高、缺乏统一的查询语法            | Web 应用、内容管理系统         | MongoDB          |
| 图形数据库   | 高效处理关系丰富的数据       | 计算量大、不易分布式                        | 社交网络、知识图谱             | Neo4J、InfoGrid  |

## 12 ※Redis 数据库

### 12.1 八种数据结构及其使用场景

- *String*：存储配置数据、缓存对象、数据统计、时间内限制请求次数。
- *Hash*：存储用户信息、商品信息、文章信息、购物车信息。
- *List*：用于最新文章、最新动态，实现消息队列等简单场景。
- *Set*：用于数据不重复的场景，获取多个数据源交集、并集和差集，随机获取数据源中的元素。
- *Zset*：用于排序场景，如排行榜、随机获取数据源中的元素根据某个权重进行排序。
- *Bitmap*：用于保存状态信息（0/1 即可表示）的场景，如用户签到情况、活跃用户情况、用户行为统计。
- *HyperLogLog*：用于基数计数，数量量巨大（百万、千万级别以上）的计数场景，如热门网站访问 ip 数统计、热门帖子 uv 统计。
- *Geospatial*：用于管理使用地理空间数据的场景，如附近的人。

### 12.2 持久化机制

- *RDB*：默认的持久化方式，将 Redis 中的数据以快照的形式写入磁盘。快速恢复数据，但宕机数据可能丢失。
- *AOF*：将每一个写命令都追加到文件中，做到秒级数据持久化，但恢复速度较慢。设置三种同步策略：always、everysec 和 no。
- *混合持久化*：结合 RDB 和 AOF 的优点，提高数据可靠性。

### 12.3 Redis 集群

- *主从复制模式*：通过将主节点的数据复制到从节点实现数据冗余和备份。主节点负责写操作，从节点负责读操作，实现读写分离。
	- **优点**：配置简单。实现数据冗余和读写分离，提高数据可靠性和读取性能。
	- **缺点**：无法自动故障转移，需要手动干预。受单节点内存限制，扩展性有限。
	- **适用场景**：数据备份、读写分离和在线升级场景。
- *哨兵模式*：在主从复制基础上添加哨兵节点，实现自动故障转移。
	- **优点**：提高高可用性，自动故障转移。具有主从复制的其他优点。
		- **缺点**：配置和管理相对复杂。
		- **适用场景**：高可用性要求较高的场景。
- *Cluster 模式*：通过数据分片和分布式存储实现负载均衡和大规模数据存储。将数据分为 16384 个槽位，每个节点负责一部分槽位。
	- **优点**：实现大规模数据存储、负载均衡和自动故障转移。支持数据分片和分布式存储，扩展性强。
	- **缺点**：配置和管理较复杂。某些复杂操作受限，例如不支持跨槽位的事务。
	- **适用场景**：大规模数据存储和高性能要求的场景。

### 12.4 常见生产问题

- *缓存穿透*：大量请求的 key 不存在于缓存和数据库中，导致请求都落到数据库上。
	- 参数校验，合法性检查，对非法请求直接返回异常。
	- 缓存无效 key，即使查不到数据也将 key-value 写入缓存，设置短暂过期时间。
	- 使用布隆过滤器，先判断 key 是否存在，不存在则直接返回，存在再进行后续处理（布隆过滤器可能出现"假阳性"的情况）。
- *缓存击穿*：热点数据在缓存过期的瞬间，大量请求打到数据库。
	- 设置热点数据永不过期或过期时间较长。
		- 请求数据写入缓存前，先获取互斥锁，保证只有一个请求会落到数据库。
		- 提前预热，将热点数据提前加载到缓存中。
- *缓存雪崩*：大量缓存在同一时间失效，大量请求直接落到数据库。
	- 采用 Redis 集群，避免单机故障。
	- 限流，避免同时处理大量请求。
	- 多级缓存，例如本地缓存+Redis 缓存。
	- 设置不同的失效时间，避免集中失效。
	- 缓存预热，主动加载热点数据到缓存。

### 12.5 缓存和数据库一致性问题

**缓存旁路模式**：
- *读取数据*：先查询缓存，如果缓存中存在所需数据，则直接返回；如果缓存中没有，则查询数据库，获取数据并将数据写入缓存。
- *写入/更新数据*：先更新数据库，然后直接删除缓存中对应的数据。下次读取时会自动从数据库中加载最新数据到缓存。

**更新失败处理**：
- 如果更新数据库成功但删除缓存失败，可以增加缓存更新重试机制，隔一段时间进行重试，重试次数可以自定义。
- 引入消息队列实现异步重试，将删除缓存重试的消息投递到消息队列，由专门的消费者来重试，直到成功。
- 尽管引入消息队列增加了复杂性，但整体收益更高。

### 12.6 过期数据删除策略

**惰性删除**：
- *描述*：只在取出 key 的时候才对数据进行过期检查。
- *优点*：对 CPU 最友好。
- *缺点*：可能会造成太多过期 key 没有被删除。

**定期删除**：
- *描述*：每隔一段时间抽取一批 key 执行删除过期 key 的操作。
- *优点*：减少过期 key 的堆积。
- *实现细节*：Redis 底层会通过限制删除操作执行的时长和频率来减少对 CPU 时间的影响。

### 12.7 内存淘汰策略

- **noeviction（默认策略）**：当内存使用达到上限时拒绝所有写入，确保数据完整性但影响可用性。
- **volatile-lru（最近最少使用）**：从已设置过期时间的键中淘汰最近最少使用的数据，适合缓存场景。
- **allkeys-lru（全局最近最少使用）**：从所有键中淘汰最近最少使用的数据，也适合缓存场景。
- **volatile-random（随机淘汰）**：从已设置过期时间的键中随机淘汰。
- **allkeys-random（全局随机淘汰）**：从所有键中随机淘汰。
- **volatile-ttl（最小 TTL 优先）**：从已设置过期时间的键中淘汰剩余 TTL 最小的，适合缓存即将过期的数据。

### 12.8 大 Key

**定义**：
- 单个成员体积大或者成员数量多。
- 例如：一个 String 类型的 Key 值为 5MB；一个 ZSET 类型的 Key 成员数量为 10,000 个；一个 Hash 类型的 Key 成员数量为 2,000 个但总大小为 100MB。

**导致的问题**：
- 客户端执行命令的时长变慢。
- Redis 内存达到上限引发操作阻塞或重要 Key 被逐出。
- 集群架构下，某个数据分片的内存使用率远超其他数据分片，无法使内存资源达到均衡。
- 删除大 Key 时，易造成主库较长时间的阻塞，进而可能引发同步中断或主从切换。

**解决方案**：
- 对大 Key 进行拆分。例如将含有数万成员的一个 HASH Key 拆分为多个 HASH Key,并确保每个 Key 的成员数量在合理范围。在 Redis 集群架构中，拆分大 Key 能对数据分片间的内存平衡起到显著作用。
- 对大 Key 进行清理。将不适用 Redis 能力的数据存至其它存储，并在 Redis 中删除此类数据。
- 对过期数据进行定期清理。堆积大量过期数据会造成大 Key 的产生，例如在 HASH 数据类型中以增量的形式不断写入大量数据而忽略了数据的时效性。可以通过定时任务的方式对失效数据进行清理。

### 12.9 热 Key

**定义**：
- QPS 集中在特定的 Key。例如，Redis 实例的总 QPS 为 10,000，其中一个 Key 的每秒访问量达到 7,000。
- 带宽使用率集中在特定的 Key。例如，对一个拥有上千个成员且总大小为 1MB 的 HASH Key 每秒发送大量的 HGETALL 操作请求。
- CPU 使用时间占比集中在特定的 Key。例如，对一个拥有数万个成员的 Key(ZSET 类型)每秒发送大量的 ZRANGE 操作请求。

**导致的问题**：
- 占用大量的 CPU 资源，影响其他请求并导致整体性能降低。
- 集群架构下，产生访问倾斜，某个数据分片被大量访问，其他数据分片处于空闲状态，可能引起该数据分片的连接数被耗尽，新的连接建立请求被拒绝。
- 热 Key 的请求压力超出 Redis 的承受能力易造成缓存击穿，大量请求直接指向后端的存储层，导致存储访问量激增甚至宕机，影响其他业务。

**解决方案**：
- 在 Redis 集群架构中对热 Key 进行复制。在 Redis 集群架构中，由于热 Key 的迁移粒度问题，无法将请求分散至其他数据分片，导致单个数据分片的压力无法下降。此时，可以将对应热 Ky 进行复制并迁移至其他数据分片，例如将热 Key foo 复制出 3 个内容完全一样的 Key 并名为 foo2、foo3、foo4,将这三个 Key 迁移到其他数据分片来解决单个数据分片的热 Key 压力。
- 使用读写分离架构。如果热 Key 的产生来自于读请求，您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力，甚至可以不断地增加从节点。但是读写分离架构在增加业务代码复杂度的同时，也会增加 Redis 集群架构复杂度。不仅要为多个从节点提供转发层（如 Proxy,LVS 等）来实现负载均衡，还要考虑从节点数量显著增加后带来故障率增加的问题。Redis 集群架构变更会为监控、运维、故障处理带来了更大的挑战。

### 12.10 Redis 指令集

#### 字符串 (Strings)

1. **SET key value**：设置字符串的值。
2. **GET key**：获取字符串的值。
3. **INCR key**：将字符串(整数值)加 1。
4. **DECR key**：将字符串 (整数值)减 1。
5. **APPEND key value**：向字符串追加值。

#### 列表 (Lists)

1. **LPUSH key value**：在列表头部插入元素。
2. **RPUSH key value**：在列表尾部插入元素。
3. **LPOP key**：从列表头部弹出元素。
4. **RPOP key**：从列表尾部弹出元素。
5. **LRANGE key start stop**：获取列表中指定范围的元素。

#### 集合 (Sets)

1. **SADD key member \[member…\]**：向集合添加一个或多个成员。
2. **SREM key member \[member…\]**：从集合中删除一个或多个成员。
3. **SPOP key**：从集合中随机移除并返回一个成员。
4. **SCARD key**：获取集合的成员数。

#### 有序集合 (Sorted Sets)

1. **ZADD key score member\[score member…\]**：向有序集合添加一个或多个成员，每个成员关联一个分数。
2. **ZREM key member \[member…\]**：从有序集合中删除一个或多个成员。
3. **ZRANGE key start stop \[WITHSCORES\]**：获取有序集合中指定分数范围的成员。

#### 散列 (Hashes)

1. **HSET key field value**：在散列中设置字段的值。
2. **HGET key field**：从散列中获取字段的值。
3. **HGETALL key**：获取散列中的所有字段和值。

#### 位图 (Bitmaps)

1. **SETBIT key offset value**：在字符串对象中设置位的值。
2. **GETBIT key offset**：获取字符串对象中位的值。

#### 超日志 (HyperLogs)

1. **PFADD key element\[element …\]**：向 HyperLogLog 中添加元素。
2. **PFCOUNT key**：返回 HyperLogLog 的近似基数。

#### 地理空间(Geospatial)

1. **GEOADD key longitude latitude member \[longitude latitude member…\]**：将地理空间位置的元素添加到键中。
2. **GEODIST key memberl member2**：返回两个地理空间位置之间的距离。
3. **GEORADIUS key longitude latitude radius m|km|ft|mi \[WITHCOORD\]\[WITHDIST\]\[WITHHASH\]**：返回位于给定坐标周围指定半径内的所有元素。

#### 键管理

1. **KEYS pattern**：查找所有匹配给定模式的键。
2. **DEL key\[key…\]**：删除一个或多个键。
3. **EXPIRE key seconds**：为键设置生存时间。

#### 事务

1. **MULTI**：开始一个事务块。
2. **EXEC**：执行事务块中的所有命令。
3. **WATCH key \[key…\]**：监视一个或多个键，如果在执行事务期间这些键被修改，则事务将失败。

#### 持久化

1. **SAVE**：将数据同步到磁盘。
2. **BGSAVE**：在后台异步保存数据到磁盘。

### 12.11 分布式锁

#### 基于数据库表

**实现方式**：
- 创建一张锁表，通过操作该表中的数据来实现锁。
- 锁住某个方法或资源时，在表中增加一条记录。
- 释放锁时，删除这条记录。

**存在的问题**：
- 锁强依赖数据库的可用性，数据库单点故障会导致业务系统不可用。
- 锁没有失效时间，解锁操作失败会导致锁记录一直在数据库中，其他线程无法获得锁。
- 锁是非阻塞的，insert 操作失败会直接报错，没有获得锁的线程不会进入排队队列。
- 锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。

#### 使用 Redisson 的分布式锁

**实现方式**：
- 支持 Redis 单实例、Redis 主从、Redis Sentinel、Redis Cluster 等多种部署架构。
- 开启一个定时器的守护线程，每隔 `expireTime/3` 检查锁是否存在，如果存在则重新设置过期时间为 `expireTime`，防止锁提前释放。

**特点**：
- 分布式锁是非阻塞的，需要使用 `while` 重复执行。
- 可重入的，因为 Redisson 的锁是 `hset` 结构，`key` 值是客户端的身份标识，`value` 是加锁次数。

#### 使用 ZooKeeper 实现分布式锁

**实现方式**：
- 客户端连接 ZooKeeper，在 `/tmp` 下创建临时且有序的子节点。
- 客户端获取 `/lock` 下的子节点列表，判断创建的节点是否为当前子节点列表中序号最小的节点，如果是则获得锁，否则监听前一个子节点的删除消息。
- 获取锁后，执行业务代码流程，删除当前客户端对应的子节点，释放锁。

**优点**：
- 解决单点问题、不可重入问题、非阻塞问题以及锁无法释放的问题。
- 实现起来较为简单。

**缺点**：
- 高并发场景下，性能不如使用 Redis 实现分布式锁，因为 ZooKeeper 集群采用 zab 一致性协议。

## 13 ※MongoDB 数据库

MongoDB 中的记录是一个文档，它是由字段和值对组成的数据结构。MongoDB 文档类似于 JSON 对象。字段的值可以包括其他文档，数组和文档数组。它的优势是

- 文档（即对象）对应于许多编程语言中的内置数据类型。
- 嵌入式文档和数组减少了对连接的需求。

**数据类型**：
- **BSON**：BSON 是一种类 JSON 的一种二进制形式的存储格式，简称 Binary JSON,它和 JSON 一样，支特内嵌的文档对象和数组对象，但是 BSON 有 JSON 没有的一些数据类型，如 Date 和 BinData 类型。
- **GeoJSON**：GeoJSON 是一种用于描述地理数据的开放标准格式，它不是 MongoDB 独有的。MongoDB 提供了对 GeoJSON 格式的原生支持，允许您在 MongoDB 数据库中存储和查询地理空间数据。地理空间索引和查询可用于实现诸如位置服务、位置分析等应用场景。

**高可用 (副本复制)**：
- MongoDB 复制集由一组 MongoDB 实例（进程）组成，包含一个 Primary 节点和多个 Secondary 节点，MongoDB Driver(客户端)的所有数据都写入 Primary,Secondary 从 Primary 同步写入的数据，以保特复制集内所有成员存储相同的数据集，提供数据的高可用。
- Primary 与 Secondary 之间通过 oplog 来同步数据，Primary 上的写操作完成后，会向特殊的 local.oplog.Is 集合写入一条 oplog,Secondary 不断的从 Primary 获取新的 oplog 并应用。

**分片集群分片策略**：
- 哈希分片：适用于随机的数据访问，无法确定特定的数据范围。哈希分片使用哈希索引来在分片集群中对数据进行划分。哈希索引计算某一个字段的哈希值作为索引值，这个值被用作片键。
- 范围分片：适用于数据按某个属性连续增长的场景，如按时间顺序存储的数据。基于范围的分片会将数据划分为由片键值确定的连续范围。这允许在连续范围内读取目标文档的高效查询。但是，如果片键选择不佳，则读取和写入性能均可能降低。

## 14 ※ElasticSearch

定义：

- Elasticsearch（简称 ES）是一个开源的分布式、高度可扩展的全文搜索和分析引擎。
- 适用于包括文本、数字、地理空间、结构化和非结构化数据等在内的所有类型数据。
- 可以用来实现分布式数据存储、日志统计、分析、系统监控、地理空间查询等功能。

底层技术：

- 最底层的搜索引擎技术是 Apache 基金会开源的搜索引擎类库 Lucene。
- Lucene 提供了搜索引擎核心 API，ES 在 Lucene 的基础上提供了分布式支持，可以水平扩展。
- 提供了 Restful 这种简洁的访问接口，能被任何语言调用。

**倒排索引原理**: 倒排索引也叫反向索引，通过词条找到包含这些词条的文档。

**倒排索引实现**：对文档数据按照 id 进行索引存储。对文档中的数据分词，记录词条在文档中出现的位置。

**倒排索引优势**：允许快速的全文搜索，不需要扫描整个文档集合，提高了搜索效率。

eg：
假设我们有以下三个文档：

1. 苹果是一种水果。
2. 香蕉是一种热带水果。
3. 苹果和香蕉都是水果。

创建的倒排索引：

1. 苹果: \[1,3\]
2. 香蕉: \[2,3\]  

搜索"苹果"时，索引列表会告诉我们"苹果"包含在文档 1 和文档 3 内。
