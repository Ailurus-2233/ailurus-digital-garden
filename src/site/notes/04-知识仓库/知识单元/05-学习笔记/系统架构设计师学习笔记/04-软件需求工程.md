---
{"dg-publish":true,"permalink":"/04//05//04/","title":"04-软件需求工程","tags":["软考","系统架构设计师"]}
---


所属知识库：[[04-知识仓库/归纳目录/05-学习笔记/系统架构设计师学习笔记\|系统架构设计师学习笔记]]

## 1 概述

1. 从选择角度来看，本章内容值得重点关注，特别是软件需求分析中的**结构化分柝数据流图，数据字典，面向对象分析中的用例模型，类图，顺序图，活动图**等，以及需求管理中红字标出的相关概念。
2. 从案例考察角度来看，此章节中**结构化分析，面向对象分析中**的内容都可能当作一小问进行考察，直接考察相关概念，比如数据流图平衡原则，数据流图基本规范等，面向对象分析中用例图的概念，面向对象分析活动过程，类的关系，活动图，顺序图，状态图，流程图之间的异同比较等。
3. 论文部分重点考察点就是**需求管理，结构化和面向对象分析方法**，2019 年下半年考过《论系统需求分析方法》，2018 年已经考察《论软件系统需求获取技术及应用》，2017 年考察过《论需求分析方法及应用》，2016 年已经考察过《论软件需求验证方法及应用》，2013 年考察过《论面向对象建模方法的应用》，2012 年考察过《论软件需求管理及其应用》。

软件需求工程是包括创建和维护软件需求文档所必需的一切活动的过程，**可分为需求开发和需求管理两大工作**。**需求开发包括需求获取、需求分析、编写需求规格说明书（需求定义）和需求验证 4 个阶段**。**需求管理通常包括定义需求基线、处理需求变更和需求跟踪等方面的工作**。

1. ==软件需求概述==：
		- 软件需求是指用户对新系统在功能、行为、性能、设计约束等方面的期望。
		- 需求是多层次的，包括业务需求、用户需求和系统需求。
		- 质量功能部署（QFD）技术将软件需求分为常规需求、期望需求和意外需求。
2. ==需求获取==：
		- 需求获取是一个确定和理解不同项目干系人的需求和约束的过程。
		- 主要方法包括用户访谈、问卷调查、采样、情节串联板和联合需求计划。
		- 用户访谈分为结构化和非结构化形式，需在准备、访谈过程和后续工作方面进行组织。
		- 问卷调查克服了用户访谈的局限性，但存在缺乏灵活性和信息不全面等缺点。
		- 采样技术用于从种群中选出有代表性的样本集，通过公式确定样本大小。
		- 情节串联板通过图片辅助讲故事的方式叙述需求，有助于高效准确地沟通。
		- 联合需求计划（JRP）通过客户或最终用户的参与加速应用程序的设计和开发过程。
3. ==需求分析==：
		- 需求分析的任务包括绘制系统上下文范围关系图、创建用户界面原型、分析需求可行性等。
		- 主要方法有结构化分析方法（SA）、面向对象分析方法（OOA）和面向问题域的分析方法（PDOA）。
		- SA 方法的基本思想是自顶向下，逐层分解，把一个大问题分解成若干个小问题。
		- OOA 方法基于抽象、信息隐藏等理念，通过观测问题域事物的表象来建立逻辑对象。
4. ==结构化分析方法（SA）==：
		- SA 方法的核心是数据字典，围绕数据字典有三个层次的模型，分别是数据模型、功能模型和行为模型。
		- 数据流图（DFD）是 SA 方法中的重要工具，表达系统内数据的流动并通过数据流描述系统功能。
		- 状态转换图（STD）描述系统对内部或外部事件响应的行为模型。
5. ==面向对象分析方法（OOA）==：
		- OOA 方法的基本任务是运用面向对象方法，对问题域进行分析和理解。
		- 统一建模语言（UML）是一种用于描述、可视化和文档化软件系统的标准建模语言。
		- UML 包括类图、对象图、组件图、部署图、用例图、顺序图、活动图、状态图等。
		- 用例模型包括识别参与者、合并需求获得用例、细化用例描述和调整用例模型。
6. ==需求定义==：
		- 需求定义的过程是形成需求规格说明书的过程，通常使用严格定义方法和原型方法。
		- 软件需求规格说明书（SRS）是需求开发活动的产物，用于使项目干系人与开发团队对系统初始规定有共同理解。
7. ==需求验证==：
		- 需求验证确保需求符合良好特征，包括需求评审和需求测试。
		- 需求评审包括评审、检查和走查三种类型。
		- 需求测试在需求开发阶段进行概念测试用例设计。
8. ==需求管理==：
		- 需求管理包括需求变更管理和需求风险管理。
		- 需求变更管理涉及定义需求基线、变更管理的流程和变更控制。
		- 需求风险管理包括识别风险和应对措施。
9. ==需求跟踪==：
		- 需求跟踪是将单个需求和其他系统元素之间的依赖关系和逻辑联系建立跟踪。
		- 需求跟踪的内容包括正向跟踪和反向跟踪。
		- 需求跟踪矩阵用于表示需求和其他系统元素之间的联系链。

## 2 软件需求概述

1. ==软件需求定义==：
		- 软件需求是指用户对新系统在**功能、行为、性能、设计约束**等方面的期望。
		- 简单地说，软件需求就是系统必须完成的事以及必须具备的品质。
2. ==需求层次==：
		- 需求是多层次的，包括**业务需求、用户需求和系统需求**。
		- 这三个层次从目标到具体，从整体到局部，从概念到细节。
3. ==质量功能部署（QFD）==：
		- **QFD 是一种将用户要求转化成软件需求的技术，目的是最大限度地提升软件工程过程中用户的满意度**。
		- QFD 将软件需求分为三类：**常规需求、期望需求和意外需求**。

## 3 需求获取

1. ==需求获取定义==：
		- **需求获取是一个确定和理解不同的项目干系人的需求和约束的过程。**
2. ==用户访谈==：
		- 用户访谈是获取需求的基本手段，分为**结构化和非结构化两种形式**。
		- 用户访谈具有灵活性，但也存在困难，需要系统架构设计师具备经验和沟通能力。
3. ==问卷调查==：
		- 问卷调查可克服用户访谈的局限性，但也有缺点。
		- 问卷调查的优点是高效、低成本、匿名、便于整理统计，缺点是缺乏灵活性、信息不全面、不利于细节回答、返还率低。
		- 可将用户访谈和问卷调查结合使用，先问卷调查，再针对结果进行小范围访谈。
4. ==采样==：
		- 采样是指从种群中系统地选出有代表性的样本集的过程。
		- 样本大小公式：样本大小 = α×(可信度系数/可接受的错误)²  
		- 采样技术可用于收集数据、采集访谈或观察用户，能加快数据收集、提高效率、降低成本、减少偏差。
5. ==情节串联板==：
		- 情节串联板是一系列图片，通过图片辅助讲故事的方式叙述需求，有助于高效准确地沟通。
		- 情节串联板的优点是生动、用户友好、交互性强，能对用户界面提供早期评审，缺点是花费时间多，降低需求获取速度。
6. ==※联合需求计划（JRP）==：
		- JRP 是一种方法论，**旨在通过客户或最终用户的参与来加速应用程序的设计和开发过程**。
		- JRP 通常通过两到五天的集会，**让开发者与顾客进行深入合作，以快速有效地探讨并达成共识，从而产生完整的需求文件**。
7. ==其他需求获取方法==：
		- **收集资料**：通过查阅已有的文档、报告、学术论文、行业标准和其他相关文献来获取需求信息。
		- **获取文档**：向相关人员索取与项目相关的文档，包括需求说明书、项目计划、流程图等。
		- **参加业务实践**：通过参与实际的业务流程和操作，亲身体验和观察业务活动，获取需求信息。

## 4 需求分析

1. ==需求分析任务==：
		- 需求分析的工作通常包括以下 7 个方面：
				- 绘制系统上下文范围关系图  
				- 创建用户界面原型  
				- 分析需求可行性  
				- 确定需求优先级  
				- 建立需求分析模型  
				- 创建数据字典  
				- 使用质量功能部署（QFD）
2. ==需求分析的方法==：
		- 主要方法有**结构化分析方法（SA）、面向对象分析方法（OOA）和面向问题域的分析方法（PDOA）**。
		- SA 方法关注功能的分层和分解，基于科学方法进行分析。
		- OOA 方法基于抽象、信息隐藏等理念，通过观测问题域事物的表象来建立逻辑对象。
		- PDOA 方法强调描述而非建模，其核心元素是问题框架，通过将问题域分为子域来获取更多信息。
3. ==需求分析的特性==：
		- 一个好的需求应该具有**无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性、必要性**等特性。
		- 需求分析的工作是把杂乱无章的用户要求和期望转化为用户需求。

## 5 ※结构化分析方法 SA

1. ==SA 方法的基本思想==：
		- **自顶向下，逐层分解，把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题。**  
		- 经过逐层分解，每个最底层的问题都是足够简单、容易解决的。
2. ==分析模型==：
		- **分析模型的核心是数据字典**，围绕这个核心，有三个层次的模型，分别是**数据模型、功能模型和行为模型（也称为状态模型）**。
		- **数据模型一般使用 E-R 图表示，功能模型用 DFD 表示，行为模型用状态转换图（STD）表示**。
3. ==数据流图（DFD）==：
		- **DFD 是 SA 方法中的重要工具，表达系统内数据的流动并通过数据流描述系统功能。**  
		- DFD 的基本符号包括**数据流、加工、数据存储和外部实体**。
		- DFD 的层次包括**顶层图和逐层分解**。
			- *顶层图：顶层图是描述系统最高层结构的 DFD,它的特点是将整个待开发的系统表示为一个加工，将所有的外部实体和进出系统的数据流都画在一张图中。*  
			- *逐层分解：当完成了顶层图的建模之后，就可以在此基础上进行进一步的分解。*  
		- **数据流图的平衡原则：父图与子图平衡，子图内部的平衡**。
			- *父图 (上层数据流图) 与 子图 (下层数据流图) 平衡。个数一致：两层数据流图中的数据流个数一致。方向一致：两层数据流图中的数据流方向一致。*  
			- *子图内部的平衡。黑洞：加工只有输入没有输出。奇迹：加工只有输出没有输入。灰洞：加工中输入不足以产生输出。每个数据存储必须既有读的数据流，又有写的数据流。但是在某张子图中，可能只有读没有写，或者只有写没有读。*
4. ==状态转换图（STD）==：
		- 状态转换图是一种描述系统对内部或外部事件响应的行模型。
		- 定义的状态主要有初态、终态和中间状态。
		- 状态转换图中使用的主要符号包括初态、终态、状态、事件表达式等。
		- 初态用黑圆点表示，终态用黑圆点外加一个圆表示，状态图中的状态用圆角四边形表示，状态之间状态转换用带箭头的线表示。
		- 在一张状态转换图中只能有一个初态，而终态则可以没有，也可以有多个。
5. ==数据字典==：
		- 数据字典是描述数据信息的集合，是对系统中使用的所有数据元素的定义的集合。
		- 数据字典的作用是在软件分析和设计过程中提供数据描述，是数据流图必不可少的辅助资料。
		- 数据字典中包括**数据元素、数据结构、数据流、数据存储、加工逻辑和外部实体**等条目。

## 6 ※面向对象分析方法

1. ==面向对象分析方法的基本任务==：
		- **运用面向对象方法**，对问题域进行分析和理解，正确认识其中的事物及它们之间的关系。
		- **找出描述问题域和系统功能所需的类和对象**，定义它们的属性和职责，以及它们之间所形成的各种联系。
		- **最终产出一个符合用户需求，并能直接反映问题域和系统功能的分析模型及其详细说明**。
2. ==统一建模语言（UML）==：
		- **定义**：UML 是一种用于描述、可视化和文档化软件系统的标准建模语言。
		- **结构**：UML 的结构包括*构造块、规则和公共机制*三个部分。
		- **图类型**：
				- **结构图**：*用来描述事物之间的关系，包括类图、对象图、组件图和部署图*。
				- **行为图**：用来描述参与者和用例之间的交互，或者描述参与者如何使用系统，包括*用例图、顺序图、活动图、状态图和通信图*。
		- **4+1 架构模型**：
			- *逻辑视图*。逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。
			- *进程视图*。进程视图是可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。
			- *实现视图*。实现视图对组成基于系统的物理代码的文件和构件进行建模。
			- *部署视图*。部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。
			- *用例视图*。用例视图是最基本的需求分析模型。
		- **UML2.0 的 14 种图**：
				- **类图**：描述类、接口、协作及它们之间的关系。
				- 对象图：描述对象及对象之间的关系。
				- 包图：描述包及包之间的相互依赖关系。
				- 组合结构图：描述系统某一部分（组合结构）的内部结构。
				- 构件图：描述构件及其相互依赖关系。
				- 部署图：展示构件在各节点上的部署。
				- 外廓图：展示构造型、元类等扩展机制的结构。
				- **顺序图**：展示对象之间消息的交互，强调消息执行顺序的交互图。
				- 通信图/协作图：展示对象之间消息的交互，强调对象协作的交互图。
				- 时间图：展示对象之间消息的交互，强调真实时间信息的交互图。
				- 交互概览图：展示交互图之间的执行顺序。
				- **活动图**：描述事物执行的控制流或数据流。
				- **状态机图**：描述对象所经历的状态转移。
				- **用例图**：描述一组用例、参与者及它们之间的相互关系。
3. ==用例模型==：
		- **构建用例模型**：一般需要经历*识别参与者、合并需求获得用例、细化用例描述和调整用例模型*四个阶段。
		- **用例图的元素**：包括参与者、用例和通信关联。
				- **参与者**：与系统进行交互的外部实体，可以是*人、其他系统、硬件设备或系统时钟*。
				- **用例**：系统提供的服务，描述参与者与系统之间的对话。
				- **通信关联**：表示参与者和用例之间或用例与用例之间的关系。
		- **识别参与者**：识别与系统交互的所有事物。参与者是与系统交互的所有事物，该角色不仅可以由人承担，还可以是其他系统和硬件设备，甚至是系统时钟，要注意的是，参与者一定在系统之外，不是系统的一部分。
		- **合并需求获得用例**：将识别到的参与者和合并生成的用例通过用例图的形式整理出来。
		- **细化用例描述**：包括*用例名称、简要说明、事件流、非功能需求、前置条件和后置条件、扩展点、优先级*等部分。
		- ※**调整用例模型**：利用*包含、扩展和泛化*关系，把一些公共的信息抽取出来，以便于复用，使得用例模型更易于维护。
			- *包含关系* 当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例。其中"\<\<include\>\>"是包含关系的构造型，箭头指间抽象用例。
			- *扩展关系* 如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。其中"\<\<extend\>\>" 是扩展关系的构造型，箭头指向基本用例。
			- *泛化关系* 当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。其中三角箭头指向父用例。
4. ※==分析模型==：
		- **描述系统的基本逻辑结构**，*展示对象和类如何组成系统（静态模型），以及它们如何保持通信，实现系统行为（动态模型）*。
		- **建立分析模型的过程**：CRC 建模  
				- **定义概念类**：识别和定义系统中的类和对象。
				- **确定类之间的关系**：包括*关联、依赖、泛化、聚合、组合和实现*等六大关系。
					- *关联关系（联系）*。关联关系是一种强语义联系的结构关系，表明两个事物之间存在着明确的、稳定的语义联系。在 UML 图中，关联关系用一条直线表示，直线的两端分别用箭头指向关联的两个类。
					- *依赖关系（联动）*。两个类 A 和 B，如果 B 的变化可能会引起 A 的变化，则称类 A 依赖于类 B。在 UML 图中，依赖关系用一条虚线表示，线的箭头指向被依赖的类。
					- *泛化关系（父子）*。泛化关系是一种继承关系，表示一般与特殊的关系。在 UML 图中，泛化关系用一条带三角箭头的实线表示，箭头指向父类。
					- *聚合关系（不同生命周期）*。聚合关系是整体与部分之间的关系，整体与部分之间是一种弱关联关系。在 UML 图中，聚合关系用一条带空心菱形的实线表示，菱形指向整体。
					- *组合关系（同生命周期）*。组合关系是整体与部分之间的关系，整体与部分之间是一种强关联关系。在 UML 图中，组合关系用一条带实心菱形的实线表示，菱形指向整体。
					- *实现关系（实现接口）*。实现关系是接口与实现类之间的关系。在 UML 图中，实现关系用一条带空心三角箭头的虚线表示，箭头指向接口。
				- **为类添加职责**：*包括维护的知识（属性）和执行的行为（成员方法或责任）*。
					- 属性：类的属性是描述类的特征的变量，用于描述类的状态。
					- 方法：类的方法是描述类的行为的函数，用于描述类的操作。
				- **建立交互图**：使用**顺序图**、交互概览图、通信图和定时图等表示对象之间的交互。
5. ==顺序图==：
	1. **定义**：
			- 顺序图（Sequence Diagram）用于显示对象间的交互活动，关注对象之间消息传送的时间顺序。
	2. **核心概念**：
			- **对象/生命线（Object/Lifeline）**：表示对象及其在交互中的存在时间。
			- **执行发生（Execution Occurrence）**：表示对象在生命线上执行某项操作的时间段。
			- **消息（Message）**：表示对象之间传递的信息。
					- **同步消息（Synchronous Message）**：发送消息的对象等待接收对象处理完消息后返回结果。
					- **异步消息（Asynchronous Message）**：发送消息的对象不等待接收对象处理消息的结果。
					- **返回消息（Return Message）**：表示消息处理后的返回结果。
					- **创建消息（Create Message）**：表示创建一个新的对象。
			- **交互片段（Interaction Frame）**：UML2 中的新增概念，用于封装交互图中的片段，并可对片段施加一定的操作（如选择、循环、并行等），从而使 UML 支持复杂的交互建模。
	3. **推荐使用场合**：
			- **用例分析**：用于分析用例中的对象交互。
			- **用例设计**：用于设计用例实现中的对象交互。
6. ==活动图==：
	1. **定义**：
			- 活动图（Activity Diagram）是一种动态行为图，用于展示业务流程或其他计算的结构，展示内部一步步的控制流和数据流，主要用于描述某一方法、机制或用例的内部行为。
	2. **核心概念**：
			- **活动/动作（Activity/Action）**：表示某个内部的控制逻辑。
			- **对象（Object）**：与活动相关的数据对象。
			- **发送事件（SendEvent）**：表示发送消息的事件。
			- **接收事件（AcceptEvent）**：表示接收消息的事件。
			- **转移（Transition）**：表示活动之间的先后顺序。
			- **分支（Decision）**：表示控制流的分支。
			- **并发（Concurrency）**：表示活动间的并发。
			- **同步（Synchronization）**：表示活动间的同步。
			- **分区（Partition）**：描述活动的不同参与者。
	3. **推荐使用场合**：
			- **业务建模**：用于描述业务过程。
			- **需求**：用于描述系统需求。
			- **类设计**：用于描述类的内部行为。
7. ==状态图==：
	1. **定义**：
			- 状态机图（State Machine Diagram），在 UML1.x 中称为状态图（State Diagram），用于描述对象本身的行为，利用状态和事件描述对象的状态变化。
	2. **核心概念**：
			- **状态（State）**：表示对象在生命周期中的不同状态。
			- **初态（Initial State）**：表示对象的初始状态。
			- **终态（Final State）**：表示对象的最终状态。
			- **事件（Event）**：表示触发状态转移的事件。
			- **转移（Transition）**：表示从一个状态到另一个状态的转换。
			- **动作（Action）**：表示在状态转移时执行的动作。
			- **并发状态机（Concurrent State Machine）**：表示多个状态机同时运行。
	3. **推荐使用场合**：
			- **类设计**：用于描述类的内部行为，特别是那些具有复杂状态转换的类。
8. ==系统建模语言==：
	1. **定义**：
			- 系统建模语言（SysML）是一种用于系统工程应用程序的通用系统体系结构建模语言，支持各种系统和系统中系统的规范、分析、设计、验证和验证。这些系统可能包括硬件、软件、信息、过程、人员和设施。SysML 是 UML2 的一种方言，被定义为 UML2 概要文件。
	2. **UML 与 SysML 的比较**：
			- **UML 的局限性**：
					- **缺乏系统级视角**：UML 主要关注单个软件应用，而不是多个软件或中间件如何协同工作。
					- **功能描述不全面**：UML 的用例图主要描述软件功能，但对于物理系统或者中间件的交互可能描述不足。
					- **缺乏对非功能性需求的描述**：例如，UML 不太适用于描述系统的可靠性、性能等方面。
			- **SysML 的优势**：
					- **系统级视角**：SysML 能更好地描述多个组件（包括软件和非软件）如何协同工作。
					- **全面的需求分析**：除了功能需求，SysML 还可以描述非功能性需求，如性能、可靠性等。
					- **更丰富的交互描述**：SysML 提供了用于描述复杂系统内部和外部交互的建模元素。
			- **SysML 的局限性**：
					- **学习曲线陡峭**：SysML 学习曲线可能比 UML 更陡峭。
					- **团队熟悉度**：如果团队成员已经很熟悉 UML，那么使用 SysML 可能需要一段时间的学习和适应。
	3. **SysML 的包和图**：
			- **包**：SysML 的语言结构以包的形式存放，包括模型参数和语法机制。SysML 重用了 UML2.0 中的大多数包以及 UML2.0 的语言机制，扩展了一些新的功能机制，如类包、活动包等，新增了 UML 中没有的包，如装配包、需求包、参数包。
			- **图**：包括结构图、需求图、行为图等。
					- **结构图**：如类图、对象图、包图、组合结构图、构件图、部署图、外廓图。
					- **行为图**：如活动图、顺序图、通信图、状态机图、用例图。

## 7 需求定义

1. ==定义==：
		- 需求定义是系统架构设计师在获取了用户的需求，并进行了详细分析之后，将这些需求形成文档，作为系统后续开发的基础。这个过程也称为需求基线。
2. ==需求规格说明书（SRS）==：
		- **目的**：使项目干系人与开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。
		- **内容**：包括项目视图和范围文档、用例文档和 SRS，以及相关的分析模型。
3. ==需求定义的方法==：
		- **严格定义方法**：通过详细的需求分析和文档化来明确系统的需求。
		- **原型方法**：通过创建系统原型来帮助用户和开发团队更好地理解和定义需求。
4. ==需求规格说明书（SRS）的编制==：
		- **目标**：确保项目干系人和开发团队对系统需求有共同的理解。
		- **内容**：包括功能需求、非功能需求、接口需求、性能需求等。
		- **重要性**：SRS 是后续开发、测试和验收的基础，确保所有工作都基于一致的需求理解。

## 8 需求验证

1. ==定义==：
		- 需求验证，也称为需求确认，*是指在系统分析阶段检测需求规格说明书（SRS）中的错误，确保需求符合良好特征*。
2. ==需求评审==：
		- **目的**：*发现 SRS 中的二义性、不确定性等问题，为项目干系人提供在需求问题上达成共识的方法*。
		- **类型**：
				- **评审**：正式的会议，向用户或其他项目干系人介绍工作产品，以征求对方的意见和批准。
				- **检查**：由非制作者的个人或小组详细检查工作产品，以验证是否有错误、是否违反开发标准、是否存在其他问题。
				- **走查**：由某个开发人员领导一个或多个开发团队成员对他（或她）的工作产品进行检查，由其他成员提出意见。
3. ==需求测试==：
		- **概念测试用例**：*在需求开发阶段，基于文本需求进行"概念"上的测试*。
		- **示例**：包括对用例的详细测试步骤和预期结果，确保需求的可测试性和可验证性。
4. ==需求验证的重要性==：
		- **在系统开发的早期阶段发现和纠正错误，可以节省大量的时间和资金**。
		- **确保需求符合良好特征，如无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性和必要性。**

## 9 ※需求管理

1. ==定义==：
	- **在 CMM 中，需求管理是可重复级的一个关键过程域，其目标是为软件需求建立一个基线，供软件开发及其管理使用，使软件计划、产品和活动与软件需求保持一致。**
		- **需求管理是确保软件需求在整个项目生命周期中保持一致性的过程，包括创建和维护软件需求文档所必需的一切活动**。
2. ==需求管理的内容==：
	- **变更控制**：管理需求变更的过程，确保变更得到适当的评估和实施。
		- 建议变更
		- 分析影响
		- 做出决策
		- 交流
		- 合并
		- 测量需求的稳定性
	- **版本控制**：管理需求文档的版本，确保所有变更都有记录。
		- 确定需求文档的版本
		- 确定单个需求文档的版本
	- **需求跟踪**：确定需求文档的版本，跟踪需求的每个状态。
		- 定义对其他需求的连接链
		- 定义对其他系统元素的连接链
	- **需求状态跟踪**：定义需求状态，跟踪需求的每一个状态。
		- 定义需求状态
		- 跟踪需求的每一个状态
3. ==需求变更管理==：
		- **需求基线**：**需求开发的结果应该有项目视图和范围文档、用例文档和 SRS,以及相关的分析模型。** 根据 EEE 的定义，**基线是指已经通过正式评审和批准的规约或产品，它可以作为进一步开发的基础，并且只能通过正式的变更控制系统进行变化。在软件工程范围内，基线是软件开发中的里程碑**，其标志是有一个或多个软件配置项的交付，且已经经过正式技术评审而获得认可。
		- **变更管理的流程**：
				- **变更申请**：提出需求变更的请求。
				- **变更评估**：评估变更的影响和成本。
				- **通告评估结果**：向相关干系人通报变更评估结果。
				- **变更实施**：实施批准的变更。
				- **变更验证与确认**：验证变更是否按预期实现。
				- **变更发布**：发布变更后的需求文档。
		- **变更管理流程 2**：
			- 识别问题  
			- 问题分析和变更描述  
			- 变更分析和成本计算  
			- 变更实现
4. ==需求风险管理==：
		- **带有风险的做法**：包括无足够用户参与、忽略用户分类、用户需求的不断增加、模棱两可的需求、不必要的特性、过于精简的 SRS、不准确地估算等。
	- 需求有关的风险与应对措施：
		- 需求获取阶段
			- 产品视图与范围：在项目早期写一份项目视图与范围，将业务需求涵盖在内，并作为新的需求及修改需求的指导
			- 所需时间：记录参与的每个项目中实际需求开发的工作量，这样就能知道所花的时间是否合适，并改进将来项目的工作计划
			- 忽略市场对产品的反馈信息：强调市场调查研究，建立原型，并运用客户核心小组来获得产品的反馈信息
			- 没有非功能需求：编写非功能需求文档和验收标准，作为可接受的标准
			- 客户反对产品需求：确定出主要的客户，并采用产品代表的方法来确保客户代表的积极参与，确保在需求决定权上有正确的人选
			- 期望需求：尽量识别并记录用户的期望，提出大量的问题来提示用户，以充分表达他们的想法和建议
			- 把已有的产品作为需求基线：将在逆向工程中收集的需求编写成文档，并让用户评审以确保其正确性
			- 给出期望的解决办法：从用户描述的解决方法中提炼出其本质需求
		- 需求分析阶段
			- 划分需求优先级：评估每项新需求的优先级，并与已有的工作对比，以做出相应的决策
			- 带来技术困难的特性：分析每项需求的可行性，以确定是否能按计划实现
			- 不熟悉的技术、工具/平台：明确那些高风险的需求，并留出充裕时间进行学习、实验和测试原型
		- 需求定义阶段
			- 系统分析师和用户对需求的不同理解：使用高水平的系统分析师；使用模型和原型，使一些模糊的需求变得清晰
			- 时间压力对待确定因素：记录解决每项待确定因素的负责人的名字、如何解决的，以及解决的截止日期
			- SRS 的完整性和正确性：以用户的任务为中心，采用用例技术获取需求；根据场景编写需求测试用例，建立原型；让用户代表对 SRS 和分析模型进行正式评审
			- 具有二义性的术语：建立一本术语和数据字典，用于定义所有的业务和技术词汇
			- 需求说明中包括了设计：仔细评审 SRS,以确保它是在强调"做什么"，而不是"怎么做"
		- 需求验证阶段
			- 未经验证的需求评审：从用户代表方获得参与需求正式评审的承诺，并尽早通过非正式评审
			- 审查的有效性：对参与需求评审的所有人员进行培训，以使评审工作更加有效
		- 需求管理阶段：
			- 需求变更：将项目视图与范围文档作为变更的参照；用户积极参与需求获取过程；将那些易于变更的需求用多种方案实现，并在设计时注意其可修改性
			- 需求变更过程：建立规范的变更控制流程，并严格执行
			- 未实现的需求：使用需求跟踪能力矩阵或相关工具
			- 项目范围蔓延：在项目早期编制视图与范围文档，并得到用户确认；采用迭代式开发方法

## 10 需求跟踪

1. **定义**：
	- 需求跟踪是将单个需求和其他系统元素之间的依赖关系和逻辑联系建立跟踪的过程。
2. **需求跟踪的内容**：
	- **双向可追踪性**：包括正向跟踪和反向跟踪。
		- **正向跟踪**：检查 SRS 中的每个需求是否都能在后继工作成果中找到对应点。
		- **反向跟踪（逆向跟踪）**：检查设计文档、代码、测试用例等工作成果是否都能在 SRS 中找到出处。
3. **需求跟踪的目的**：
	- **审核**：帮助开发人员审核和确保所有需求都被正确应用。
	- **变更影响分析**：在增、删、改需求时，确保不忽略每个受到影响的系统元素。
	- **维护**：提高维护时实施变更的生产率。
	- **项目跟踪**：获得计划功能当前实现状态的记录。
	- **再工程**：列出遗留系统中将要替换的功能，记录它们在新系统中的需求和在软件构件中的位置。
	- **重复利用**：帮助开发人员在新系统中对相同的功能利用现有系统的相关资源。
	- **减小风险**：减少由于项目团队关键成员离职带来的风险。
	- **测试**：在测试出错时指出最可能有问题的代码段。
4. **需求跟踪矩阵**：
	- **需求跟踪矩阵**：表示需求和其他系统元素之间的联系链的最普遍方式是使用需求跟踪矩阵。
