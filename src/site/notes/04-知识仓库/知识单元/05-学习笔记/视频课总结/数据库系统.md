---
{"dg-publish":true,"permalink":"/04//05///","title":"数据库系统","tags":["公共基础课","软考","系统架构设计师"]}
---


所属知识库：[[04-知识仓库/归纳目录/05-学习笔记/视频课总结\|视频课总结]]

## 总览

1. 数据库模式
	- **三级模式**：外模式、概念模式、内模式
	- **两级独立性**：物理独立性和逻辑独立性
2. 关系模型结构 关系、元组、属性、属性值、主码、域、关系模式
	- **运算关系**：包括集合运算（并、差、交）和关系代数运算（选择、投影、连接）；笛卡尔积是两个关系的所有组合；自然连接是特殊的θ连接，去除重复属性；
	- **元组演算**：元组演算是关系模型的一部分，提供宣告式的数据库查询语言；使用原子公式和运算符（如 `∃`、`∀`、`￢`、`∧`、`∨`）进行查询。
3. 数据库设计与建模
	- **概念设计**
			- **ER 图概念**: 实体-关系图 (ER 图) 是用于概念设计的工具，用于表示实体类型、属性和实体之间的关系。
			- **整体 ER 图设计**: 创建全局 ER 图，将业务需求映射为概念模型，包括所有主要实体和关系。
	- **逻辑设计**
			- **ER 图转换**: 将概念 ER 图转换为逻辑关系模式。
			- **反规范化异常**: 通过反规范化提升查询性能，理解反规范化带来的数据异常，包括插入、删除和更新异常。
			- **五大范式**: 第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、BCNF、第四范式（4NF）及第五范式（5NF）。
			- **函数依赖**: 理解属性间的函数依赖关系及其对数据库设计的影响。
			- **键/码/属性**: 区分候选键、主键和属性，理解其在数据库中的作用。
			- **无损连接**: 确保数据库表在分解后的无损连接特性，保证数据的完整性。
			- **保持函数依赖**: 在关系分解过程中保持关键函数依赖，防止数据冗余和异常。
4. 数据仓库
	- **OLAP vs OLTP**: 理解联机事务处理 (OLTP) 和联机分析处理 (OLAP) 的差异。
	- **数据仓库设计**: 数据仓库的架构与设计，基于星型和雪花模式的数据模型。
	- **ETL 过程**: 数据抽取 (Extract)、转换 (Transform) 和加载 (Load) 的基本流程与技术。
	- **数据多维模型**: 理解数据立方体、多维分析以及聚合操作。
	- **数据仓库优化**: 针对数据仓库查询的性能优化技术，包括索引设计和数据分区。
5. 数据库控制功能
	- **并发控制**
			- **事务概念**: 理解事务的 ACID 特性（原子性、一致性、隔离性、持久性）。
			- **数据一致性**: 确保数据库在并发环境中的一致性。
			- **封锁技术**: 封锁类型（排他锁、共享锁）及其在事务隔离中的作用。
			- **死锁问题**: 死锁的检测与解决策略，如等待图和超时机制。
	- **性能优化**
			- **反规范化**: 在性能优化中合理使用反规范化，平衡查询性能与数据一致性。
			- **索引优化**: 根据查询模式选择合适的索引结构，如 B-树索引、哈希索引等。
	- **完整性约束**
			- **实体完整性**: 确保每个表的每一行都有唯一的标识符 (主键)。
			- **参照完整性**: 维护表间外键关系的一致性。
			- **触发器**: 使用触发器实现复杂的业务逻辑与数据完整性约束。
	- **备份恢复**
			- **物理/逻辑备份**: 理解物理备份（如快照、镜像）与逻辑备份（如导出数据）的区别与应用。
			- **数据恢复**: 使用 redo 和 undo 日志进行事务恢复，确保数据库的一致性和完整性。
6. 数据库高级主题
	- **分布式事务**
			- **2PC/3PC**: 二阶段提交 (2PC) 与三阶段提交 (3PC) 的原理与应用，确保分布式环境下的数据一致性。
			- **CAP 定理**: 理解一致性 (Consistency)、可用性 (Availability) 和分区容忍性 (Partition Tolerance) 之间的权衡。
	- **主从复制与读写分离**
			- **一致性问题**: 在主从复制架构中维护数据一致性的方法。
			- **读写分离策略**: 通过读写分离提升数据库的并发性能。
	- **冷热数据分离**
			- **冷/热数据**: 区分冷热数据，并针对性地优化数据存储与访问策略。
	- **分区与分片技术**
			- **数据分片**: 根据业务需求对数据进行水平或垂直分片，提高数据库的扩展性。
			- **数据分区**: 逻辑上将数据划分为不同的分区，以提高查询效率和管理灵活性。
	- **NoSQL 技术**
			- **MongoDB**
					- **数据结构**: MongoDB 的文档结构、集合与 BSON 格式。
					- **高可用集群**: MongoDB 的副本集与分片集群技术。
					- **分片技术**: 在 MongoDB 中实现大规模数据的分布式存储与管理。
			- **Redis**
					- **数据结构与使用场景**: Redis 支持的各种数据结构（如字符串、哈希、列表、集合、有序集合）及其应用场景。
					- **高可用集群**: Redis 的主从复制、哨兵模式与集群模式。
					- **持久化机制**: Redis 的 RDB 和 AOF 持久化机制。
					- **一致性问题**: 在 Redis 的分布式环境中，解决数据一致性的问题。
					- **内存淘汰原则**: Redis 中的内存淘汰策略，如 LRU、LFU 等。
					- **分布式锁**: 使用 Redis 实现分布式锁的机制与最佳实践。
					- **热 key 和大 key 问题**: 处理 Redis 中的热点 key 和大 key 的方法。
			- **ElasticSearch**
					- **数据结构**: ElasticSearch 的倒排索引结构及其存储方式。
					- **高可用集群**: ElasticSearch 的分布式架构、分片和副本机制。
					- **基本原理**: ElasticSearch 的全文搜索引擎原理，包括分词、倒排索引和查询优化。
7. 分布式数据库概念
	- **体系结构**: 分布式数据库的体系结构，包括集中式、分布式与混合式。
	- **数据分片**
			- **分类**: 水平分片、垂直分片和混合分片的分类与适用场景。
			- **原则**: 数据分片的设计原则，如均衡负载、最小化跨片查询等。
			- **透明性**: 在应用层实现对数据分片的透明访问。

## 数据库模式

出题方式：选择题

数据库系统的三级模式包括：

1. **外模式**：面向**用户（包括程序员和终端用户）**，描述组成**用户视图**的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件。
2. **概念模式**：面向**数据库管理员**，用以描述现实世界中的**实体**及其性质与联系，定义记录、数据项、数据的完整性约束条件及记录之间的联系。
3. **内模式**：面向**系统程序员**，用以描述存储记录的类型、存储域的表示和**存储记录的物理顺序，以及索引和存储路径等数据**的存储组织。

数据库系统的两级独立性包括：

1. **物理独立性**：用户的**应用程序**与存储在磁盘上的数据库中的数据是相互独立的。这意味着当**数据**的物理存储结构发生变化时，用户的应用程序不需要改变。
2. **逻辑独立性**：用户的**应用程序**与数据库中的**逻辑结构**是相互独立的。当数据的逻辑结构改变时，例如增加或删除字段，应用程序不需要改变。

这两级独立性通过数据库系统的三级模式结构实现，使得数据库系统能够灵活应对各种变化，同时保护应用程序不受底层数据结构和逻辑结构变化的影响。

## 关系代数

出题方式：选择题

关系模型结构是数据库系统中的一种数据结构，它使用单一的二维表来表示数据。以下是关系模型结构的主要组成部分：

1. **关系（表文件）**：在用户看来，一个关系模型的逻辑结构是一张二维表，由行和列组成。这个二维表就叫关系，通俗地说，一个关系对应一张表。
2. **元组（记录）**：表中的一行即为一个元组，或称为一条记录。
3. **属性（字段）**：数据表中的每一列称为一个字段，表是由其包含的各种字段定义的，每个字段描述了它所含有的数据的意义。创建数据表时，为每个字段分配一个数据类型，定义它们的数据长度和其他属性。
4. **属性值**：行和列的交叉位置表示某个属性值。
5. **主码（主键或主关键字）**：是表中用于唯一确定一个元组的数据。关键字用来确保表中记录的唯一性，可以是一个字段或多个字段，常用作一个表的索引字段。
6. **域**：属性的取值范围。
7. **关系模式**：关系的描述称为关系模式。对关系的描述，一般表示为：关系名(属性 1，属性 2……属性 n)。

关系模型的这种简单的数据结构能够表达丰富的语义，描述出现实世界的实体以及实体间的各种关系。

### 集合运算符

出题方式：选择题

**基础集合运算符**：并、交、差是关系代数中的集合运算符，用于对两个关系（表）进行运算。以下是这些运算符的定义：
1. **并（Union，`R ∪ S`）**：
		- 定义：两个关系 R 和 S 的并集是由属于 R 或属于 S 或同时属于两者的所有元组组成的集合。
		- 结果：包含 R 和 S 中的所有元组，但剔除重复的元组。
2. **交（Intersection，`R ∩ S`）**：
		- 定义：两个关系 R 和 S 的交集是由同时属于 R 和 S 的所有元组组成的集合。
		- 结果：包含 R 和 S 中都存在的元组。
3. **差（Difference，`R - S`）**：
		- 定义：关系 R 与关系 S 的差是由属于 R 但不属于 S 的所有元组组成的集合。
		- 结果：包含 R 中但不在 S 中的元组。

这些运算符在关系代数中用于对关系进行组合和筛选，以得到新的关系。

**笛卡尔积（Cartesian Product）**: 笛卡尔积是关系代数中的一个运算符，用于对两个关系（表）进行组合运算。以下是笛卡尔积的定义：

1. **定义**：如果关系 R 有 u 个元组，关系 S 有 v 个元组，那么 R 和 S 的笛卡尔积将产生 u×v 个元组。笛卡尔积的结果是一个新的关系，其中每个元组都是由 R 的一个元组和 S 的一个元组组合而成。
2. **结果**：笛卡尔积的结果关系包含所有可能的 R 和 S 元组的组合。

例如，如果关系 R 有 2 个元组，关系 S 有 3 个元组，那么 R 和 S 的笛卡尔积将产生 2×3=6 个元组。

### 关系运算符

出题方式：选择题

关系运算符是关系代数中用于对关系（表）进行操作的运算符。以下是一些主要的关系运算符：

1. **选择（Selection，σ）**：
		- 定义：选择运算符用于从关系中选择满足给定条件的元组。
		- 表达式：σ<条件>(R)，其中 R 是一个关系，条件是一个逻辑表达式。
2. **投影（Projection，π）**：
		- 定义：投影运算符用于从关系中选择指定的属性列。
		- 表达式：π<属性列表>(R)，其中 R 是一个关系，属性列表是要选择的属性。可以是列号或属性名。
3. **连接（Join）**：
		- 定义：连接运算符用于从两个关系的笛卡尔积中选取属性之间满足一定条件的元组。
		- 表达式：θ连接通常表示为 R⋈<条件>S，其中 R 和 S 是两个关系，条件是一个逻辑表达式。
4. **自然连接（Natural Join）**：
		- 定义：自然连接是特殊的θ连接，如果两个关系中进行比较的分量必须是相同的属性组，并且在结果中将重复的属性去掉。
		- 表达式：通常表示为 R⋈S，其中 R 和 S 是两个关系。

这些关系运算符在关系代数中用于对关系进行组合、筛选和处理，以得到新的关系。

### 元组演算

出题方式：选择题

元组演算（Tuple Calculus）是关系模型的一部分，用于提供宣告式的数据库查询语言。以下是元组演算的主要概念：

1. **定义**：元组演算是一种基于逻辑的查询语言，它通过逻辑表达式来描述要检索的元组。元组演算表达式通常包含原子公式和逻辑运算符。
2. **原子公式**：原子公式是元组演算的基本组成部分，用于描述单个元组的属性值或元组之间的关系。
3. **逻辑运算符**：元组演算使用逻辑运算符来组合原子公式，形成更复杂的查询表达式。主要的逻辑运算符包括：
		- 存在量词（∃）：表示存在某个元组满足条件。
		- 全称量词（∀）：表示所有元组都满足条件。
		- 否定（￢）：表示逻辑非。
		- 合取（∧）：表示逻辑与。
		- 析取（∨）：表示逻辑或。
4. **查询表达式的形式**：元组演算的查询表达式通常形式为{t | 条件}，其中 t 表示元组，条件是一个逻辑表达式，描述元组需要满足的条件。
5. **应用**：元组演算为数据库查询语言提供了理论基础，QUEL 和 SQL 等查询语言的一些灵感来源于元组演算。

元组演算提供了一种抽象的方式来描述数据库查询，使得用户可以精确地指定要检索的数据。

eg:

1. `R1 = {t | R(t) ∧ ￢S(t)}` 等价于 `R - S`
		- **解释**：R1 是所有满足关系 R 但不满足关系 S 的元组集合。即从关系 R 中选择那些不在关系 S 中的元组。
2. `R2 = {t | S(t) ∧ t[3] > t[2] ∧ t[2] < 8}`
		- **解释**：R2 是所有满足关系 S，并且元组的第三个属性值大于第二个属性值，且第二个属性值小于 8 的元组集合。
3. `R3 = {t | (∃u) (R(t) ∧ S(u) ∧ t[3] < u[2])}`
		- **解释**：R3 是所有满足关系 R，并且存在一个元组 u 在关系 S 中，使得元组 t 的第三个属性值小于元组 u 的第二个属性值的元组集合。
4. `R4 = {t | (∀u) (R(t) ∧ S(u) ∧ t[3] > u[1])}`
		- **解释**：R4 是所有满足关系 R，并且对于关系 S 中的所有元组 u，元组 t 的第三个属性值都大于元组 u 的第一个属性值的元组集合。

## 数据库设计流程

出题方式：选择题，分析题

数据库设计流程主要包括以下几个阶段：

1. **需求分析**：
		- 明确系统总体设计方案，编写**需求说明书**，包括**数据流图**、建立的**数据字典**
2. **概念设计**：
		- 将需求分析得到的用户需求建立抽象的信息模型（概念模型），常用 E-R 图表示
		- **选择局部应用、逐一设计分 E-R 图和 E-R 图合并**
3. **逻辑设计**：
		- 在概念结构设计的基础上进行数据模型设计，可以是层次模型、网状模型和**关系模型**
		- 主要工作步骤包括**确定数据模型、将 E-R 图转换成为指定的数据模型、确定完整性约束和确定用户视图**
4. **物理设计**：
		- **确定数据分布、存储结构和访问方式**
		- 存储结构要选合理的物理结构，访问方式由存储结构决定
5. **数据库实施**：
		- 根据逻辑和物理设计的结果，在计算机上建立起实际的**数据库结构**，**数据加载**、进行试运行和评价的过程
6. **数据库运维**：
		- 数据库一旦投入运行，就标志着数据库维护工作的开始
		- 主要内容包括对数据库性能的监测和改善、故障恢复、数据库的重组和重构
		- 在数据运行阶段，对数据库的维护主要由 DBA 完成

### 概念设计

概念设计常用策略是运用**自顶向下方法**进行需求分析，然后运用**自底向上方法**设计概念结构

概念设计是数据库设计流程中的一个阶段，其主要任务是建立抽象的信息模型（概念模型），以反映用户需求。这个阶段的工作步骤包括：

1. **选择局部应用**：
		- 确定局部视图的范围，识别实体及其标识，确定实体之间的联系。
2. **逐一设计分 E-R 图**：
		- 为每个局部应用设计局部 E-R 图，分配实体及联系的属性。
3. **E-R 图合并**：
		- 将所有的分 E-R 图综合成一个系统的总体 E-R 图，消除冗余属性和冗余联系，解决属性冲突、命名冲突和结构冲突。
4. **优化和评审**：
		- 对全局 E-R 图进行优化，确保模型能够准确反映现实世界的需求，并进行评审以确保模型的合理性和完整性。

概念设计阶段通常使用 E-R 图（实体-关系图）作为主要工具，通过图形化的方式表示实体、属性和实体之间的联系。概念模型是现实世界的模型，易于与不熟悉计算机的用户交流，是数据库设计的基础。

#### E-R 图

E-R 图（实体-关系图）主要由以下三个基本元素组成：

1. **实体（Entity）**：实体用矩形框表示，框内标注实体名称。实体是现实世界中可以独立存在的事物或概念。
2. **属性（Attribute）**：属性用椭圆形表示，并用连线与实体连接起来。属性是描述实体的特征或性质。
		- **单值属性用实线椭圆表示**，**多值属性在椭圆形虚线外面再套实线椭圆**，**派生属性用虚线椭圆表示**。
3. **联系（Relationship）**：实体之间的联系用菱形框表示，框内标注联系名称，并用连线将菱形框分别与有关实体相连，并在连线上注明联系类型（1:1, 1:n 或 m:n）。

E-R 图在考试中的要点主要包括以下几个方面：

1. **实体的识别和表示**：识别和正确表示现实世界中的实体。
2. **属性的识别和分类**：识别实体的属性，并正确区分单值属性、多值属性和派生属性。
3. **联系的识别和表示**：识别实体之间的联系，并正确表示联系的类型（1:1, 1:n 或 m:n）。
4. **弱实体和弱关系**：理解和表示弱实体和弱关系。
5. **概化**：理解和表示不完全概化和完全概化。
6. **局部 E-R 图和全局 E-R 图的设计**：设计局部 E-R 图，并将其合并为全局 E-R 图，消除冗余和冲突。
7. **E-R 图转换为关系模式**：将 E-R 图转换为关系模式，包括 1:1、1:n 和 m:n 联系的转换规则。

- **弱实体（Weak Entity）**：弱实体是依赖于其他实体（称为强实体）而存在的实体。弱实体没有自己的独立标识符，其存在依赖于与之关联的强实体。例如，订单号可以看作是一个弱实体，因为它依赖于用户实体而存在。使用双边框表示弱实体。
- **弱关系（Weak Relationship）**：弱关系通常与弱实体一起使用，表示弱实体与强实体之间的联系。只有弱实体才会用到弱关系。使用双菱形表示弱关系。
- **不完全概化（Partial Generalization）**：不完全概化表示父实体的实例可以是子实体的实例，也可以不是任何子实体的实例。换句话说，父实体的某些实例可能不属于任何子类别。例如，职业可以概化为工程师和老师，但并不是所有的职业实例都必须属于这两个子类别之一。使用三角形一杠表示不完全概化。
- **全部概化（Full Generalization）**：全部概化表示一个父实体的所有实例必须是某个子实体的实例。这意味着没有父实体的实例独立存在，它们必须属于一个明确的子类别。例如，人可以全部概化为男人和女人，这意味着没有不属于男人或女人类别的人实例。使用三角形两道杠表示全部概化。

#### 局部 E-R 图

出题方式：选择题、分析题

局部 E-R 图主要用于以下方面：

1. **确定局部视图的范围**：
		- 识别和定义局部应用的范围，明确哪些实体和联系属于这个局部视图。
2. **识别实体及其标识、确定实体之间的联系**：
		- 识别局部视图中的实体，并确定每个实体的标识符（主键）。
		- 确定局部视图中实体之间的联系类型（1:1, 1:n 或 m:n），并表示这些联系。
3. **分配实体及联系的属性**：
		- 将属性分配给实体和联系，确保每个实体和联系都有描述其特征的属性。

#### 全局 ER 图合并

在全局 ER 图合并过程中，需要注意以下几个关键的点：

1. **合并**：
		- 确定公共实体类型，识别各个局部 E-R 图中的公共实体类型，这些公共实体类型是合并的基础。
2. **消除冗余**：
		- 消除冗余属性和冗余联系，确保全局 E-R 图中没有重复的信息。
3. **解决冲突**：
		- 解决属性冲突、命名冲突和结构冲突。
				- **属性冲突**：不同局部 E-R 图中对同一属性的定义可能不同，需要统一属性的定义。
				- **命名冲突**：不同局部 E-R 图中可能有相同的实体或联系名称，但含义不同，需要重新命名以避免混淆。
				- **结构冲突**：不同局部 E-R 图中对同一实体或联系的结构定义可能不同，需要调整以保持一致性。

通过这些步骤，可以确保全局 E-R 图能够准确、全面地表示整个系统的数据模型，为后续的逻辑设计和物理设计提供坚实的基础。

### 逻辑设计

逻辑设计是数据库设计过程中的一个重要阶段，其主要任务是将概念结构设计阶段完成的整体 E-R 模型转换为与选用的 DBMS（数据库管理系统）产品所支持的数据模型相符合的逻辑结构。具体来说，逻辑设计包括以下几个关键步骤：

1. **E-R 模型向关系模型的转换**：
		- 将 E-R 图中的实体、属性和联系转换为关系模式。实体通常转换为关系表，属性转换为表中的列，联系则根据联系类型（1:1, 1:n, m:n）转换为独立的关系表或合并到相关实体的关系表中。
2. **范式转换**：
		- 确保转换后的关系模式满足一定的范式要求（如 1NF、2NF、3NF 等），以减少数据冗余和异常，提高数据的一致性和完整性。
3. **确定完整性约束**：
		- 定义关系模式中的主键、外键、唯一性约束、非空约束等完整性约束条件，确保数据的正确性和一致性。
4. **确定用户视图**：
		- 根据用户需求，设计用户视图（虚拟表），以满足不同用户对数据的不同访问需求。

逻辑设计的目标是生成一个优化的、符合 DBMS 要求的逻辑数据模型，为后续的物理设计提供基础。

#### E-R 图转换为关系模式

E-R 图（实体-关系图）向关系模式的转换是数据库逻辑设计中的一个重要步骤。以下是详细的转换规则：

1. **实体转换为关系模式**：
		- 每个实体转换为一个关系模式（表）。
		- 实体的属性转换为关系模式的属性（列）。
		- 实体的主键作为关系模式的主键。
2. **1:1 联系转换为关系模式**：
		- 可以转换为一个独立的关系模式，也可以与任意一端实体所对应的关系模式合并。
				- **独立关系模式**：关系的属性由联系相连的各实体的主码以及联系本身的属性组成，关系的主码是每个实体的主码。
				- **与实体合并**：将联系本身的属性和另一端实体的主码加入关系模式的属性中。
3. **1:n 联系转换为关系模式**：
		- 可以转换为一个独立的关系模式，也可以与 n 端实体所对应的关系模式合并。
				- **独立关系模式**：关系的属性由与该联系相连的各实体的主码以及联系本身的属性组成，主码是 n 端实体的主码。
				- **与 n 端实体合并**：将联系本身的属性和 1 端实体的主码加入 n 端对应关系模式中。
4. **m:n 联系转换为关系模式**：
		- 通常转换为一个独立的关系模式。
		- 关系的属性由与该联系相连的各实体的主码以及联系本身的属性组成，各实体主码的组合是该关系的主码或关系主码的一部分。
5. **弱实体转换为关系模式**：
		- 弱实体依赖于强实体而存在。
		- 弱实体的关系模式中需要包含强实体的主键作为外键。
6. **多值属性转换为关系模式**：
		- 如果一个实体具有多值属性，通常需要将该多值属性转换为一个独立的关系模式。
		- 关系的属性包括实体的主键和多值属性本身。

通过这些转换规则，可以将 E-R 图中的实体、属性和联系转换为关系数据库中的表、列和关系，为后续的物理设计和数据库实现提供基础。

#### 函数依赖

函数依赖是关系数据库理论中的一个核心概念，用于描述关系模式中属性之间的依赖关系。具体来说，如果在一个关系模式中，对于属性集 X 中的每一个值，属性集 Y 中都有一个唯一确定的值与之对应，则称 Y 函数依赖于 X，记作 X → Y。以下是函数依赖的一些关键点和分类：

1. **基本定义**：
		- **函数依赖**：如果在一个关系模式中，对于属性集 X 中的每一个值，属性集 Y 中都有一个唯一确定的值与之对应，则称 Y 函数依赖于 X，记作 X → Y。
		- **平凡函数依赖**：如果 Y 是 X 的子集，则 X → Y 是平凡函数依赖。例如，(职工号，性别) → 职工号。
		- **非平凡函数依赖**：如果 Y 不是 X 的子集，则 X → Y 是非平凡函数依赖。例如，(职工号) → 姓名。
2. **分类**：
		- **完全函数依赖**：如果 X → Y，并且 X 的任意真子集都不能函数决定 Y，则称 Y 完全函数依赖于 X。
		- **部分函数依赖**：如果 X → Y，但 X 的某个真子集也能函数决定 Y，则称 Y 部分函数依赖于 X。
		- **传递函数依赖**：如果 X → Y 且 Y → Z，但 X 不函数决定 Z，则称 Z 传递函数依赖于 X。
3. **Armstrong 公理系统**：
		- **自反性**：若 X⊇Y，则存在 X → Y。
		- **增广性**：若 X → Y，则存在 XZ → YZ。
		- **传递性**：若 X → Y 和 Y → Z，则存在 X → Z。
		- **合并性**：若 X → Y 和 X → Z，则存在 X → YZ。
		- **分解性**：若 X → Y，且 Y⊇Z，则存在 X → Z。
		- **伪传递性**：若 X → Y 和 WY → Z，则存在 WX → Z。
		- **复合性**：若 X → Y 和 Z → W，则存在 XZ → YW。
		- **自增性**：若 X → Y，则存在 XW → YW。
4. **函数依赖在数据库设计中的应用**：
		- **规范化**：通过消除部分函数依赖和传递函数依赖，将关系模式分解为更规范的形式，以减少数据冗余和异常。
		- **无损连接和保持函数依赖**：在关系模式分解时，确保分解后的关系通过自然连接可以恢复成原来的关系，并且分解后的函数依赖集合与原来的函数依赖集合等价。

函数依赖是关系数据库设计中的基础理论，对于优化数据库结构、提高数据一致性和减少数据冗余具有重要意义。

#### 无损联接和保持函数依赖

1. **无损联接**：
		- **定义**：给定一个关系模式 R 及其属性集 U，以及一组函数依赖 F，如果将 R 分解为两个关系模式 R1 和 R2，那么分解是无损联接的，当且仅当通过自然联接操作将 R1 和 R2 重新组合时，能够得到与原始关系 R 完全相同的结果。
		- **条件**：无损联接的充要条件是((R1∩R2)→(R1-R2))或((R1∩R2)→(R2-R1))，即两个关系模式交集的属性集能够函数决定其中一个关系模式去除交集后的属性集。
2. **保持函数依赖**：
		- **定义**：给定一个关系模式 R 及其属性集 U，以及一组函数依赖 F，如果将 R 分解为多个关系模式 R1, R2, …, Rn，那么分解是保持函数依赖的，当且仅当分解后的所有关系模式上的函数依赖集合的并集与原始关系模式 R 上的函数依赖集合 F 等价。
		- **目的**：保持函数依赖的目的是确保分解后的关系模式仍然能够反映原始关系模式中的所有函数依赖关系，从而避免数据冗余和不一致。

#### 键、码、属性

在关系数据库理论中，键、码和属性是重要的概念，用于描述关系模式中的数据结构和标识方法。以下是这些概念的定义和区别：

1. **属性**：
		- **定义**：属性是关系模式中的一个数据项，用于描述实体的某个特征或性质。例如，在"学生"关系模式中，"学号"、"姓名"和"年龄"都是属性。
		- **分类**：属性可以是单值属性或多值属性。单值属性表示每个实体在该属性上只有一个值，而多值属性表示一个实体可以有多个值。
2. **码**：
		- **定义**：码是关系模式中能够唯一标识一个元组（记录）的属性或属性集。例如，"学号"可以作为一个码来唯一标识一个学生。
		- **分类**：
				- **超码**：一个或多个属性的集合，这些属性的组合可以唯一标识一个实体。超码可能包含多余的属性。
				- **候选码**：如果超码的任一真子集不能包括超码，则称其为候选码。候选码不包含多余的属性。
				- **主码**：被数据库设计者选中的，用来在同一实体集中区分不同实体的候选码。一个实体集中只能有一个主码，但可以有多个候选码。
3. **键**：
		- **定义**：键通常指的是主码，即用于唯一标识关系模式中每个元组的属性或属性集。
		- **分类**：
				- **主键**：关系模式中选定的一个候选码，用于唯一标识每个元组。
				- **外键**：一个关系模式中的属性或属性集，其值对应于另一个关系模式的主键，用于建立两个关系之间的联系。

**示例**：  
假设有一个"学生"关系模式，包含以下属性：学号、姓名、年龄、性别、所在专业。

- **属性**：学号、姓名、年龄、性别、所在专业都是该关系模式的属性。
- **码**：
		- 超码：{学号, 姓名}可以唯一标识一个学生，但包含多余的属性（姓名）。
		- 候选码：{学号}可以唯一标识一个学生，且不包含多余的属性。
		- 主码：通常选择"学号"作为主码。
- **键**：主键是"学号"。

键、码和属性是关系数据库设计的基础，正确理解和应用这些概念对于设计高效、一致的关系模式至关重要。

##### 求候选码

求候选键是关系数据库设计中的一个重要步骤，用于确定能够唯一标识关系模式中每个元组的最小属性集。以下是求候选键的基本步骤：

1. **确定函数依赖**：
		- 首先，需要明确关系模式中的所有函数依赖关系。例如，对于关系模式 R(A, B, C, D, E)，函数依赖集 F = {A→B, B→C, C→D, D→E}。
2. **绘制函数依赖图**：
		- 将函数依赖关系用有向图的方式表示，顶点表示属性，弧表示属性之间的依赖关系。例如，对于上述函数依赖集，绘制出的有向图如下：A → B → C → D → E
3. **找出入度为 0 的属性集**：
		- 找到图中入度为 0 的属性，这些属性是候选键的潜在组成部分。例如，在上面的图中，A 是入度为 0 的属性。
4. **尝试遍历有向图**：
		- 从入度为 0 的属性集出发，尝试遍历整个有向图。如果能够遍历所有顶点，则该属性集即为候选键。例如，从 A 出发，可以遍历到 B、C、D、E，因此 A 是候选键。
5. **考虑中间顶点**：
		- 如果入度为 0 的属性集不能遍历所有顶点，则需要尝试将一些中间顶点（既有入度也有出度的顶点）并到入度为 0 的属性集中，直到能够遍历所有顶点。例如，如果图中存在多个入度为 0 的属性，且它们各自无法遍历所有顶点，则可能需要合并这些属性集。

**示例**：  
给定关系模式 R(A, B, C, D, E)上的函数依赖集 F = {A→B, B→C, C→D, D→E}。

- **找出入度为 0 的属性集**：A 是入度为 0 的属性。
- **尝试遍历有向图**：从 A 出发，可以遍历到 B、C、D、E，因此 A 是候选键。

通过以上步骤，可以有效地确定关系模式中的候选键，从而为设计高效、一致的关系模式提供基础。

#### 规范化必要性

规范化是关系数据库设计中的一个重要过程，其目的是消除数据冗余、减少异常现象，并提高数据的一致性和完整性。以下是规范化的必要性：

1. **消除数据冗余**：
		- 数据冗余是指同一数据在数据库中多次重复存储的现象。例如，如果一个教师教授多门课程，那么该教师的姓名和地址信息会在多个元组中重复出现。规范化通过分解关系模式，将重复的数据分离到不同的表中，从而减少存储空间并避免数据不一致。
2. **减少修改异常**：
		- 修改异常是指由于数据冗余，当需要更新某个信息时，必须同时更新所有包含该信息的元组，否则会导致数据不一致。例如，如果教师地址发生变化，必须在所有包含该教师信息的元组中更新地址。规范化通过减少数据冗余，避免了这种修改异常。
3. **避免插入异常**：
		- 插入异常是指由于关系模式设计不当，某些数据无法正确插入数据库。例如，如果要插入一个新教师的个人信息，但该教师尚未教授任何课程，则无法插入该教师的信息，因为关系模式中可能要求同时提供课程信息。规范化通过分解关系模式，使得每个关系模式只包含相关的属性，从而避免了插入异常。
4. **避免删除异常**：
		- 删除异常是指由于关系模式设计不当，删除某些数据时会导致不必要的信息丢失。例如，如果要删除某门课程的信息，可能会同时删除与该课程相关的教师和学生信息。规范化通过分解关系模式，使得每个关系模式只包含相关的属性，从而避免了删除异常。
5. **提高数据一致性和完整性**：
		- 规范化通过消除数据冗余和减少异常现象，提高了数据的一致性和完整性。这使得数据库更加可靠，能够更好地支持各种业务需求。

#### 五大范式

文档中详细介绍了五大范式（1NF、2NF、3NF、BCNF、4NF），以下是对这些范式的详细说明：

1. **第一范式（1NF）**：
		- **定义**：在关系模式中，当且仅当所有属性只包含原子值，即每个分量都是不可再分的数据项，则称满足 1NF。
		- **示例**：如果一个关系模式中的某个属性包含多个值，如"高级职称人数"包含"教授"和"副教授"两个值，则不满足 1NF。将其拆分为两个独立的属性后，就满足 1NF。
2. **第二范式（2NF）**：
		- **定义**：设一个关系为 R(U)，满足第一范式，若 R 中不存在非主属性对候选码的部分函数依赖，则称该关系是符合第二范式的，即 R∈2NF。
		- **示例**：学生关系(学号，姓名，性别，所在专业，课程号，课程名，成绩)不符合 2NF，因为姓名、性别、所在专业部分依赖于(学号，课程号)。将其分解为三个关系：学生(学号，姓名，性别，所在专业)、课程(课程号，课程名)、选课(学号，课程号，成绩)，则满足 2NF。
3. **第三范式（3NF）**：
		- **定义**：设一个关系为 R(U)，满足第一范式，若 R 中不存在非主属性对候选码的传递函数依赖，则称该关系是符合第三范式的，即 R∈3NF。
		- **示例**：学生关系(学号，姓名，年龄，学校编号，学校名称，学校电话)不符合 3NF，因为存在传递依赖(学号)→(学校编号)→(学校名称，学校电话)。将其分解为两个关系：学生(学号，姓名，年龄，学校编号)、学校(学校编号，地址，电话)，则满足 3NF。
4. **BC 范式（BCNF）**：
		- **定义**：若一个关系为 R(U)，它是满足第一范式的，当 R 中不存在任何属性对候选码的传递函数依赖时，则称 R 符合 BCNF，即 R∈BCNF。
		- **示例**：关系模式(教工号，学号，课程号)不符合 BCNF，因为存在教工号→课程号，但教工号不是码。将其分解为两个关系模式：(学号，课程号)和(教工号，课程号)，则满足 BCNF。
5. **第四范式（4NF）**：
		- **定义**：第四范式是 BCNF 的推广，是针对有多值依赖的关系模型所定义的规范化形式。把一个表中多个多值依赖拆分开来。
		- **示例**：职工表(职工编号，职工孩子姓名，职工选修课程)不符合 4NF，因为存在两个多值依赖：职工孩子姓名和职工选修课程。将其分解为两个表：职工表 1(职工编号，职工孩子姓名)和职工表 2(职工编号，职工选修课程)，则满足 4NF。

通过规范化，可以消除数据冗余、减少异常现象，并提高数据的一致性和完整性。

## 数据库控制

出题方式：案例

**常见的考点：**

1. **事务的概念**：
		- 原子性：事务包含的一组更新操作要么全做，要么全不做。
		- 隔离性：一个事务的执行不能被其他事务干扰。
		- 一致性：事务使数据库从一个一致性状态变到另一个一致性状态。
		- 持久性：事务一旦提交，改变就是永久性的。
2. **并发控制**：
		- 数据一致性：并发环境下，事务的隔离性难以保证，会出现丢失修改、读"脏数据"、不可重复读和幻读等问题。
		- 锁与锁协议：排他型封锁（X 封锁）和共享型封锁（S 封锁），以及一级、二级、三级封锁协议和两段锁协议。
		- 并发问题：死锁、活锁、饥饿和优先级反转等问题。
		- MySQL 相关：读写锁、间隙锁、next-key 锁、意向锁等。
		- 隔离级别：读未提交、读已提交、可重复读和串行化。
3. **完整性约束**：
		- 实体完整性：关系的主属性（主键）不能为空。
		- 参照完整性：外键的值必须是另一关系中主键的值，或者为空值。
		- 触发器：在特定数据操作发生时自动执行 SQL 语句。
4. **数据库性能优化**：
		- 索引优化：建立与选择索引的原则。
		- 反规范化：冷热数据分离、计算属性设计等。
		- 其他优化：硬件升级、数据库设计、检索策略和查询优化。
5. **备份与恢复技术**：
		- 备份方法：完全备份、差异备份、增量备份、物理备份和逻辑备份。
		- 冷备份和热备份：各自的优缺点和适用场景。
		- 数据恢复：回滚日志（undo log）、重做日志（redo log）和二进制格式的日志文件（binlog）。

### 事务的概念

事务是数据库的逻辑工作单位，具有以下特性：

1. **原子性（Atomicity）**：
		- 事务包含的一组更新操作要么全做，要么全不做，是一个不可分割的工作单位。
2. **隔离性（Isolation）**：
		- 一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
3. **一致性（Consistency）**：
		- 事务使数据库从一个一致性状态变到另一个一致性状态（数据库的状态应该与预期结果相同）。
4. **持久性（Durability）**：
		- 事务一旦提交，改变就是永久性的，无论发生何种故障，都不应该对其有任何影响。

> 事务是 DBMS 运行的基本工作单位，事务是用户定义的一个数据库操作序列，是一个不可分割的工作单位，事务的定义和特性确保了数据库操作的可靠性和一致性。

### 数据一致性

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题，主要包括以下几种：

1. **丢失修改（写-写并发）**：
		- 两个或多个事务同时修改同一数据，后提交的事务会覆盖先提交的事务的修改结果，导致数据丢失。
2. **读"脏数据"（读-写并发）**：
		- 事务 A 修改某一数据，并将其写回磁盘，事务 B 读取同一数据后，事务 A 由于某种原因被撤销，这时事务 B 读到的数据就与数据库中的数据不一致，是不正确的数据，称为"脏数据"。
3. **不可重复读（读-写并发）**：
		- 事务 A 读取数据后，事务 B 执行了更新操作，事务 A 再次读取数据时，发现数据已经改变，造成了数据不一致性。
4. **幻读（读-写并发）**：
		- 事务 A 读取某个范围的数据，事务 B 在这个范围内插入新的数据，事务 A 再次读取这个范围的数据时，发现读取的结果和第一次读取的结果不同。

这些问题主要源于并发事务对数据的读写操作相互干扰，解决这些问题通常需要通过并发控制机制，如封锁协议和事务隔离级别，来保证事务的隔离性。

### 锁与锁协议

锁与锁协议是用于解决并发控制问题的重要机制，主要包括以下几种：

1. **排他型封锁（X 封锁）**：
		- 如果事务 T 对数据对象 A 实现了 X 封锁，那么只允许事务 T 读取和修改数据 A，其他事务要等事务 T 解除 X 封锁以后，才能对数据 A 实现任何类型的封锁。**X 封锁具有排他性，只允许一个事务独锁某个数据**。
2. **共享型封锁（S 封锁）**：
		- 如果事务 T 对数据 A 实现了 S 封锁，那么允许事务 T 读取数据 A，但不能修改数据 A。在所有 S 封锁解除之前，决不允许任何事务对数据 A 实现 X 封锁。**S 封锁允许并发读，但不允许修改**。

此外，还有几种封锁协议用于控制事务的并发执行：

1. **一级封锁协议**：
		- 事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。一级封锁协议保证事务可恢复，但不能防止读"脏数据"和不可重复读。
2. **二级封锁协议**：
		- 一级封锁协议加上事务 T 在读取数据 R 之前先对其加 S 锁，读完后即可释放 S 锁。二级封锁协议防止读"脏数据"，但不能保证可重复读。
3. **三级封锁协议**：
		- 一级封锁协议加上事务 T 在读取数据 R 之前先对其加 S 锁，直到事务结束才释放。三级封锁协议保证可重复读。
4. **两段锁协议**：
		- 所有事务分两个阶段对数据项加锁和解锁：加锁阶段和解锁阶段。在加锁阶段可以进行加锁操作，解锁阶段只能进行解锁操作。**两段锁协议遵守该协议的事务可能发生死锁。**

这些锁与锁协议通过控制事务对数据的访问，确保数据的一致性和事务的隔离性。

不同的锁和锁协议在处理数据一致性问题时具有不同的特点和局限性：

1. **排他型封锁（X 封锁）**：
		- **处理问题**：防止多个事务同时修改同一数据，避免丢失修改问题。
		- **存在问题**：由于其排他性，可能导致事务等待时间过长，影响并发性能。
2. **共享型封锁（S 封锁）**：
		- **处理问题**：允许多个事务同时读取同一数据，但不允许修改，避免写操作干扰读操作。
		- **存在问题**：如果多个事务长时间持有 S 锁，可能会导致写操作等待时间过长。
3. **一级封锁协议**：
		- **处理问题**：防止丢失修改。
		- **存在问题**：不能防止读"脏数据"和不可重复读问题。
4. **二级封锁协议**：
		- **处理问题**：防止丢失修改和读"脏数据"。
		- **存在问题**：不能保证可重复读，即事务在读取数据后，其他事务可能修改该数据，导致事务再次读取时数据不一致。
5. **三级封锁协议**：
		- **处理问题**：防止丢失修改、读"脏数据"和不可重复读。
		- **存在问题**：由于事务在读取数据之前必须先对其加 S 锁，直到事务结束才释放，可能会导致事务等待时间过长，影响并发性能。
6. **两段锁协议**：
		- **处理问题**：防止丢失修改、读"脏数据"、不可重复读和幻读。
		- **存在问题**：遵守该协议的事务可能发生死锁，即多个事务互相等待对方释放锁，导致系统无法继续执行。

通过这些锁和锁协议，可以有效地解决并发环境下可能出现的各种数据一致性问题，但同时也需要权衡其对系统并发性能的影响。

### Mysql 处理方案

MySQL 中的隔离级别用于控制事务的并发行为，确保数据的一致性。主要有以下四种隔离级别：

1. **读未提交（Read Uncommitted）**：
		- **特点**：事务中的修改，即使没有提交，对其他事务也是可见的。
		- **问题**：可能导致脏读、不可重复读和幻读。
2. **读已提交（Read Committed）**：
		- **特点**：一个事务提交后，其修改对其他事务可见。
		- **问题**：可能导致不可重复读和幻读。
3. **可重复读（Repeatable Read）**：
		- **特点**：事务在整个过程中可以多次读取同一数据，并保证结果一致。
		- **问题**：可能导致幻读。
4. **串行化（Serializable）**：
		- **特点**：事务被处理为顺序执行，类似于一个接一个地执行。
		- **问题**：可能导致性能下降，因为事务需要等待其他事务完成。

这些隔离级别通过控制事务的并发行为，确保数据的一致性和事务的隔离性。选择合适的隔离级别需要在数据一致性和系统并发性能之间进行权衡。

### 完整性约束

完整性约束是数据库中用于确保数据符合预定义规则的重要机制，主要包括以下几种：

1. **实体完整性**：
		- **定义**：实体完整性规则要求关系的 **主属性（主码或主键）** 的组成不能为空，即关系的主属性 **不能是空值（NULL）**。
		- **作用**：确保每个实体在数据库中都有唯一的标识符，避免出现重复或无效的记录。
2. **参照完整性**：
		- **定义**：如果基本关系 R 中含有与另一基本关系 S 的主键相对应的属性组 FK（外键），则参照完整性要求 R 中的每个元组在 FK 上的值必须是 S 中某个元组的 PK 值，或者为空值。
		- **作用**：确保关系之间的引用关系正确，避免出现悬挂引用或无效引用。
		- **问题**：插入删除更新数据时，可能会违反参照完整性，导致数据不一致。
3. **触发器**：
		- **定义**：触发器是一个数据库对象，当指定的数据操作语言（DML）操作发生时（例如 INSERT、UPDATE、DELETE），该对象可以自动执行一个或多个 SQL 语句。
		- **作用**：用于实现复杂的业务规则和约束条件，确保数据的完整性和一致性。

通过这些完整性约束，数据库系统可以有效地防止数据的不一致性和错误，确保数据的准确性和可靠性。

### 数据库性能优化

数据库性能优化可以从多个方面进行，主要包括以下几个方面：

1. **索引优化**：
		- **建立与选择原则**：分析读写操作，合理选择建立索引的列，避免过多的索引。
		- **高频优化**：对经常用于查询的列建立索引。
		- **选择建立**：根据查询需求，选择合适的索引类型（如 B 树、哈希索引等）。
2. **反规范化**：
		- **计算属性设计**：通过增加冗余列来减少 JOIN 操作，提高查询性能。
		- **重新定义实体**：通过合并相关表来减少 JOIN 操作。
3. **冷热数据分离**：
		- **热数据优化**：将经常访问的数据分离出来，存储在高速存储设备上，提高查询性能。
		- **节约成本**：将不经常访问的冷数据存储在低成本存储设备上。
4. **表分割**：
		- **水平分割**：将一个大表按照某种规则（如时间、地区等）分割成多个小表。
		- **垂直分割**：将一个表中的列按照访问频率或相关性分割成多个表。
5. **硬件升级**：
		- **增加内存**：增加数据库服务器的内存，提高缓存命中率。
		- **使用高速存储设备**：使用 SSD 等高速存储设备，提高数据读写速度。
6. **数据库设计**：
		- **合理设计表结构**：避免冗余数据，减少数据存储空间。
		- **使用合适的数据类型**：选择合适的数据类型，减少存储空间和查询时间。
7. **查询优化**：
		- **优化查询语句**：避免使用 SELECT \*，减少不必要的数据传输。
		- **使用合适的 JOIN 类型**：根据查询需求，选择合适的 JOIN 类型（如 INNER JOIN、LEFT JOIN 等）。
		- **避免子查询**：尽量使用 JOIN 代替子查询，提高查询性能。
8. **并发控制**：
		- **合理设置隔离级别**：根据业务需求，合理设置事务的隔离级别，平衡数据一致性和并发性能。
		- **使用锁机制**：合理使用锁机制，避免死锁和锁竞争。

通过以上方法，可以有效地提高数据库的性能，确保系统的稳定运行。

### 备份与恢复技术

备份与恢复技术是数据库管理的重要组成部分，用于确保数据的安全性和系统的可靠性。主要包括以下几种备份和恢复方法：

1. **完全备份**：
		- **定义**：备份整个数据库中的所有数据。
		- **优点**：恢复简单，可以恢复到备份时的完整状态。
		- **缺点**：备份时间长，占用存储空间大。
2. **差异备份**：
		- **定义**：备份自上一次完全备份后发生变化的所有数据。
		- **优点**：备份时间短，占用存储空间小。
		- **缺点**：恢复时需要上一次完全备份和所有差异备份，恢复时间较长。
3. **增量备份**：
		- **定义**：备份自上一次备份（包括完全备份、增量备份和差异备份）后发生变化的数据。
		- **优点**：备份时间短，占用存储空间小。
		- **缺点**：恢复时需要上一次备份和所有增量备份，恢复时间较长。
4. **物理备份**：
		- **定义**：在操作系统层面上对数据库的数据文件进行备份。
		- **优点**：备份速度快，恢复简单。
		- **缺点**：备份期间数据库通常需要停止服务。
5. **逻辑备份**：
		- **定义**：利用 DBMS 自带的工具软件备份和恢复数据库的内容。
		- **优点**：备份和恢复灵活，可以按表、表空间、用户等层次进行备份。
		- **缺点**：备份和恢复速度较慢，适用于数据量较小的数据库。

通过合理选择备份和恢复策略，可以确保在数据丢失或系统故障时能够快速恢复，减少数据丢失和业务中断的风险。

冷备份和热备份是数据库物理备份的两种主要方式，它们各有优缺点，适用于不同的场景。以下是冷备份和热备份的详细优缺点说明：

#### 物理备份

##### 冷备份

**优点**：

1. **备份速度快**：由于数据库处于停止状态，只需复制文件即可完成备份，因此备份速度非常快。
2. **容易归档**：备份过程简单，只需复制相关文件即可，容易进行归档管理。
3. **容易恢复到某个时间点上**：只需将备份的文件再复制回去即可恢复到备份时的状态。
4. **能与归档方法相结合**：可以结合归档方法做数据库"最佳状态"的恢复。
5. **低度维护，高度安全**：备份过程简单，维护工作量小，安全性高。

**缺点**：

1. **数据库不可用**：在实施备份的全过程中，数据库必须停止服务，不能进行其他工作，影响业务连续性。
2. **恢复时间点限制**：单独使用时，只能提供到某一时间点上的恢复，无法实现更细粒度的恢复。
3. **存储空间限制**：若磁盘空间有限，只能复制到磁带等其他外部存储设备上，速度会很慢。
4. **无法按表或按用户恢复**：只能恢复整个数据库，无法按表或按用户进行恢复。

##### 热备份

**优点**：

1. **数据库仍可使用**：备份过程中数据库仍然可以使用，不影响业务连续性。
2. **备份时间短**：可以在表空间或数据库文件级进行备份，备份时间短。
3. **秒级恢复**：可以实现秒级恢复，恢复到某一时间点上。
4. **按需恢复**：可以对几乎所有数据库实体进行恢复，如表、表空间等。
5. **快速恢复**：恢复速度快，可以快速恢复到备份时的状态。

**缺点**：

1. **复杂性高**：备份过程复杂，需要特别注意备份的完整性和一致性。
2. **风险高**：若热备份不成功，所得结果不可用于时间点的恢复。
3. **维护难度大**：维护工作量大，需要特别小心，不允许"以失败告终"。

##### MyySQL 相关

MySQL 的物理备份可以分为冷备份和热备份两种方式。以下是这两种备份方式的详细流程：

**冷备份流程：**

1. **停止 MySQL 服务**：
		- 首先，需要停止 MySQL 数据库服务，确保数据库处于停机状态。可以使用以下命令停止 MySQL 服务：systemctl stop mysql
2. **备份数据文件**：
		- 一旦 MySQL 服务停止，可以备份 MySQL 的数据文件。通常，MySQL 的数据文件存储在 `/var/lib/mysql/` 目录下。可以直接对该目录进行备份，或者使用压缩工具如 `tar` 对其进行打包压缩。例如：`tar -czf mysql_backup.tar.gz /var/lib/mysql/`
3. **备份配置文件**：
		- 另外，可能还需要备份 MySQL 的配置文件，通常位于 `/etc/mysql/my.cnf` 或 `/etc/my.cnf`。`cp /etc/mysql/my.cnf my.cnf_backup`
4. **启动 MySQL 服务**：
		- 完成备份后，启动 MySQL 服务，恢复数据库的正常运行。`systemctl start mysql`

**热备份流程：**

1. mysqldump 是 MySQL 提供的备份工具，可以对 MySQL 数据库进行逻辑备份。可以使用以下命令备份整个数据库或指定数据库：`mysqldump -u [username] -p [database_name] > backup.sql`
2. 这将把数据库备份到一个 SQL 脚本文件中。在恢复时，可以使用以下命令：`mysql -u [username] -p [database_name] < backup.sql`

##### 注意事项

- **冷备份**：在备份期间，数据库必须停止服务，不能进行其他工作，影响业务连续性。
- **热备份**：备份过程中数据库仍然可以使用，但需要特别注意备份的完整性和一致性，维护工作量大。

根据实际业务需求和资源情况，合理选择冷备份或热备份策略，可以确保在数据丢失或系统故障时能够快速恢复，减少数据丢失和业务中断的风险。

##### 总结

- **冷备份**适用于对业务连续性要求不高、备份时间窗口较宽的场景，优点是备份速度快、操作简单，缺点是在备份期间数据库不可用。
- **热备份**适用于对业务连续性要求高、需要实时备份的场景，优点是备份期间数据库仍然可用，缺点是需要特别注意备份的完整性和一致性，维护工作量大。

根据实际业务需求和资源情况，合理选择冷备份或热备份策略，可以确保在数据丢失或系统故障时能够快速恢复，减少数据丢失和业务中断的风险。

#### 逻辑备份 Mysql/Oracle

逻辑备份是数据库备份的一种方法，它通过导出数据库中的数据和结构来生成备份文件。以下是逻辑备份的主要优点和问题：

**优点:**

1. **简单方便**：
		- 逻辑备份操作简单，容易理解和实现。可以通过数据库自带的工具或命令行工具完成备份。
2. **灵活**：
		- 可以按表、表空间、用户和全库等不同层次进行备份和恢复操作，提供了较高的灵活性。
3. **易于管理**：
		- 备份文件通常是文本格式，便于管理和查看。可以直接编辑备份文件进行数据修改或修复。
4. **跨平台兼容性**：
		- 逻辑备份文件通常与平台无关，可以在不同的操作系统和数据库版本之间迁移数据。

**问题:**

1. **备份和恢复速度慢**：
		- 对于大型数据库，逻辑备份和恢复的速度较慢。随着数据量的增加，备份和恢复所需的时间会显著增加。
2. **资源消耗大**：
		- 逻辑备份过程中会占用较多的系统资源，如 CPU 和内存，可能影响数据库的性能。
3. **数据一致性**：
		- 在备份过程中，如果数据库有大量的写操作，可能会导致备份的数据不一致。因此，通常需要在备份期间减少或停止写操作。
4. **不支持部分恢复**：
		- 逻辑备份通常不支持部分恢复，即无法恢复到某个特定的时间点或事务状态，只能恢复到备份时的状态。
5. **数据量大**：
		- 备份文件可能会非常大，占用大量的存储空间，特别是在全库备份的情况下。

> [!info] 总结  
> 逻辑备份适用于数据库容量不大、备份时间窗口较宽的场景，优点是操作简单、灵活方便，缺点是在大型数据库中备份和恢复速度慢、资源消耗大。随着数据量的增加，逻辑备份可能无法满足备份和恢复的需求，此时可以考虑使用物理备份或增量备份等其他备份策略。

#### 数据恢复

在数据库系统中，为了确保数据的一致性和持久性，通常会使用多种日志来记录事务操作和系统状态，以便在发生故障时进行数据恢复。以下是几种常见的数据恢复日志：

1. 回滚日志（Undo Log）
	- **功能**：记录事务对数据所做的修改，用于事务回滚和 MVCC（多版本并发控制）。
	- **作用**：在事务失败或需要回滚时，通过回滚日志可以撤销未提交的事务操作，恢复到事务开始前的状态。
2. 重做日志（Redo Log）
	- **功能**：记录事务对数据页所做的物理修改，用于故障恢复。
	- **作用**：在系统崩溃或断电等情况下，通过重做日志可以将未写入磁盘的数据重新写入，确保事务的持久性。
3. 二进制日志（Binlog）
	- **功能**：记录所有数据库表结构变更和表数据修改的逻辑操作。
	- **作用**：用于数据备份和主从复制。在数据恢复时，可以通过二进制日志重放操作，恢复到故障发生前的状态。

## 分布式数据库

**总览：**

1. **分布式数据库特点**：
		- 数据独立性：包括逻辑独立性和物理独立性，以及数据分布独立性（分布透明性）。
		- 数据冗余：在不同场地存储同一数据的多个副本，提高可靠性和可用性。
		- 集中与自治共享结合的控制结构：各局部 DBMS 可以独立管理局部数据库，同时设有集中控制机制。
		- 全局的一致性、可串行性、可恢复性：确保数据合法、并发事务结果一致，以及系统在故障后能恢复到一致状态。
2. **分布式数据库体系结构**：
		- 数据分片：将数据库逻辑结构分解为片段，定义片段及其副本的物理分布，提高访问局部性。
		- 用户级数据库：包括全局外模式、外模式、用户视图等。
		- 概念级数据库：全局概念模式、概念模式-内模式映射等。
		- 物理级数据库：内模式、局部概念模式、局部内模式等。
3. **数据分片**：
		- 水平分片：将全局关系中的元组分裂成多个子集，通过并操作重构全局关系。
		- 垂直分片：将全局关系按属性分裂成多个子集，通过连接运算重构全局关系。
		- 导出分片：水平分片的条件不是本关系属性的条件，而是其他关系属性的条件。
		- 混合分片：同时使用水平分片和垂直分片。
4. **分布式事务**：
		- CAP 理论：分布式系统最多只能同时满足一致性、可用性和分区容错性中的两项。
		- BASE 理论：牺牲强一致性以获得可用性，允许数据在一段时间内不一致，但最终达到一致性状态。
		- 常用解决方案：包括 2PC/3PC、TCC、SAGA、本地消息表、MQ 消息事务等。
5. **解决方案-两阶段提交协议 2PC**：
		- 事务预处理/投票阶段：协调者询问参与者是否可以执行事务，参与者执行事务操作并反馈结果。
		- 事务提交：所有参与者反馈成功，协调者发送提交请求，参与者正式执行事务提交。
		- 中断事务：存在参与者反馈失败或超时，协调者发送回滚请求，参与者执行回滚操作。

### 分布式数据库的特点

分布式数据库的特点主要包括以下几点：

1. **数据独立性**：
		- 数据的逻辑独立性和物理独立性。
		- 数据分布独立性（分布透明性），即用户或应用程序不必考虑数据的具体分布情况。
2. **数据冗余**：
		- 在不同的场地存储同一数据的多个副本，以提高系统的可靠性和可用性，同时也能提高系统性能。
3. **集中与自治共享结合的控制结构**：
		- 各局部的 DBMS 可以独立地管理局部数据库，具有自治的功能。
		- 系统又设有集中控制机制，协调各局部 DBMS 的工作，执行全局应用。
4. **全局的一致性、可串行性、可恢复性**：
		- **一致性**：确保数据在任何事务执行后都保持合法状态。
		- **可串行性**：保证并发事务的结果与某种顺序串行执行的结果一致，是并发控制的理想状态。
		- **可恢复性**：确保系统在故障后能够恢复到一致状态，是系统可靠性的保证。

这些特点使得分布式数据库系统能够在保持数据一致性和高可用性的同时，具备更好的扩展性和容错能力。

### 分布式数据库体系结构

分布式数据库的体系结构主要包括以下几个层次：

1. **用户级数据库**：
		- **全局外模式**：用户视图，外模式 A、外模式 B 等。
		- **外模式-概念模式映射**：映射 1。
2. **概念级数据库**：
		- **全局概念模式**：全局 DBMS。
		- **概念模式-分片模式映射**：映射 2。
		- **分片模式**：定义片段及其副本在各场地的物理分布。
3. **物理级数据库**：
		- **分布模式**：定义片段及其副本在各场地的物理分布。
		- **概念模式-内模式映射**：映射 3。
		- **内模式**：局部概念模式、局部内模式等。
4. **局部数据库**：
		- **局部概念模式**：局部 DBMS 管理的数据库模式。
		- **局部内模式**：局部数据库的物理存储结构。
5. **物理数据库**：
		- 存储实际的数据片段和副本。

总结起来，分布式数据库的体系结构通过多层次的设计，实现了数据的逻辑和物理分布透明性，使得用户和应用程序可以透明地访问和管理分布在不同场地的数据。

#### 数据分片的方式

1. **水平分片**：
		- 将一个全局关系中的元组分裂成多个子集，每个子集为一个片段。
		- 分片条件由关系中的属性值表示。
		- 重构全局关系可通过关系的并操作实现。
		- 常见的分片算法有哈希分片和范围分片。
2. **垂直分片**：
		- 将一个全局关系按属性分裂成多个子集，应满足不相交性（关键字除外）。
		- 重构全局关系可通过连接运算实现。
		- 在实际应用中，通常是将一个包含了很多表的数据库，根据表的功能的不同，拆分为多个小的数据库，每个库中包含部分表。
3. **导出分片**：
		- 又称为导出水平分片，水平分片的条件不是本关系属性的条件，而是其他关系属性的条件。
		- 例如，关系 SC（学生选修课表，学号，课程号，成绩）可以根据学号关联学生表（学号，性别），然后用学生的性别来分片。
4. **混合分片**：
		- 在分片中采用水平分片和垂直分片两种形式的混合。

此外，数据分片的原则包括完整性、重构性、分片透明性、位置透明性、不相交性和局部数据模型透明性等。这些原则确保了数据分片后的正确性和一致性。

#### 数据分片/分布原则

**数据分布原则：**  

1. **分片透明性**：
		- 是分布透明性的最高层次，用户或应用程序只对全局关系进行操作而不必考虑数据的分片。
2. **位置透明性**：
		- 用户或应用程序应当了解分片情况，但不必了解片段的存储场地。
3. **局部数据模型透明性**：
		- 用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部数据模型。

**数据分片原则：**

1. **完整性**：
		- 全局关系的所有数据都必须分配到各个片段中，不允许某些数据属于全局关系但不属于任何片段。
2. **重构性**：
		- 各个片段可以重构原来的全局关系。
3. **不相交性**：
		- 全局关系中的每个元组仅属于一个片段，不能在多个片段中重复出现。

### 分布式事务

#### CAP 理论

CAP 理论是指计算机分布式系统的三个核心特性：一致性 (Consistency)、可用性 (Availability) 和分区容错性 (Partition Tolerance)。在分布式系统中，最多只能同时满足其中的两个特性。

1. **一致性 (Consistency)**：
		- 多个节点上的数据副本必须保持一致。
2. **可用性 (Availability)**：
		- 系统必须在任何时候都能够响应客户端请求。
3. **分区容错性 (Partition Tolerance)**：
		- 系统必须能够容忍分布式系统中的某些节点或网络分区出现故障或延迟。

#### BASE 理论

BASE 理论是对 CAP 理论中一致性和可用性权衡的结果，其核心思想是通过牺牲强一致性来获得高可用性，并允许数据在一段时间内是不一致的，但最终达到一致性状态。

1. **基本可用 (Basically Available)**：
		- 分布式系统在出现不可预知故障的时候，允许损失部分可用性。
2. **软状态 (Soft State)**：
		- 允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
3. **最终一致性 (Eventually Consistent)**：
		- 强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。

> BASE 理论是对 CAP 理论的一种补充和延伸，通过牺牲强一致性来获得高可用性，适用于大规模分布式系统的设计和实现。

#### 分布式事务方案

本质上来说，分布式事务就是为了保证不同数据库的数据一致性。(SANTA)

1. **两阶段提交协议 (2PC)**：
		- **事务预处理/投票阶段**：
				- 事务询问：协调者向所有参与者发送事务内容，询问是否可以执行提交操作，并开始等待各参与者进行响应。
				- 执行事务：各参与者节点执行事务操作，并将 Undo 和 Redo 操作计入本机事务日志。
				- 反馈响应：各参与者向协调者反馈事务问询的响应，成功执行返回 Yes，否则返回 No。
		- **事务提交**：
				- 所有参与者返回 Yes，协调者向所有参与者发送 Commit 请求，事务提交。
				- 参与者收到 Commit 请求后，正式执行事务提交操作，并在完成提交操作之后，释放占用的资源。
		- **中断事务**：
				- 当存在某一参与者向协调者发送 No 响应，或者等待超时，协调者中断事务。
				- 协调者向所有参与者发送 Rollback 请求，参与者收到请求后，利用本机 undo 信息执行 Rollback 操作。
2. **三阶段提交协议 (3PC)**：
		- 在 2PC 的基础上增加了一个预提交阶段，以减少阻塞时间和单点故障问题。
3. **TCC (Try-Confirm-Cancel)**：
		- **Try 阶段**：尝试执行，完成所有业务检查（一致性），预留必须业务资源（准隔离性）。
		- **Confirm 阶段**：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，要求具备幂等性。
		- **Cancel 阶段**：取消执行，释放 Try 阶段预留的业务资源，Cancel 操作满足幂等性。
4. **本地消息表**：
		- 在本地数据库中记录消息的发送状态，结合异步消息队列，实现事务的最终一致性。
		- 系统收到用户请求，将业务数据和消息数据写入同一个数据库，更新订单和存储消息为同一个本地事务。
		- 另起定时任务，定时扫描本地消息表，看是否有未完成的任务，有则重试。
5. **MQ 消息事务**：
		- 通过消息队列的可靠消息传递机制，确保消息的最终一致性。
6. **最大努力通知**：
		- 在某些情况下，通过多次通知机制，确保事务的最终一致性。

这些解决方案各有优缺点，适用于不同的业务场景和需求。在实际应用中，需要根据系统的具体需求和特性选择合适的解决方案。

#### 分布式事务解决方案存在的问题

1. **两阶段提交协议 (2PC)**：
		- **性能问题**：在 2PC 提交过程中，所有参与事务操作的逻辑都处于阻塞状态，占用系统资源。
		- **单点故障**：2PC 协议的协调者是个单点，一旦协调者出现问题，其他参与者将无法释放事务资源，也无法完成事务操作。
		- **数据不一致**：当执行事务提交过程中，如果协调者向所有参与者发送 Commit 请求后，发生局部网络异常或者协调者自身崩溃，可能只有部分参与者收到并执行了请求，导致整个系统出现数据不一致的情况。
		- **保守机制**：2PC 没有完善的容错机制，当参与者出现故障时，协调者无法快速得知，只能严格依赖超时设置来决定是否继续提交或中断事务。
2. **三阶段提交协议 (3PC)**：
		- **复杂性**：3PC 在 2PC 的基础上增加了预提交阶段，虽然减少了阻塞时间和单点故障问题，但增加了系统的复杂性。
3. **TCC (Try-Confirm-Cancel)**：
		- **代码实现复杂度**：TCC 将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，代码实现复杂度相对较高。
		- **业务耦合**：TCC 需要将业务逻辑拆分为多个阶段，增加了业务系统的耦合度。
4. **本地消息表**：
		- **高耦合**：本地消息表与业务场景绑定，高耦合，占用业务系统资源，量大可能会影响数据库性能。
		- **延迟**：由于消息是异步发送和处理的，可能会引入一定的延迟。
5. **MQ 消息事务**：
		- **复杂性**：需要确保消息队列的可靠性和事务的最终一致性，增加了系统的复杂性。
		- **消息丢失**：在某些情况下，消息队列可能出现消息丢失的情况，需要额外的机制来保证消息的可靠传递。
6. **最大努力通知**：
		- **多次通知**：需要多次通知机制来确保事务的最终一致性，增加了系统的复杂性和通信成本。

总结来说，每种分布式事务解决方案都有其特定的优缺点和适用场景。在实际应用中，需要根据系统的具体需求和特性选择合适的解决方案。

## 数据库系统

NoSQL（Not Only SQL 或非 SQL）是一种数据库设计方法，用于在关系数据库的传统结构之外存储和查询数据。以下是对 NoSQL 数据库的简要介绍：

1. **定义**：
		- NoSQL 数据库不使用关系数据库的典型表结构，而是将数据存储在非关系数据结构中，如 JSON 文档。
		- NoSQL 数据库是一种分布式数据库类型，将信息复制并存储在不同的服务器上，确保数据的可用性和可靠性。
2. **优势**：
		- **可扩展性**：能够快速扩展以管理大型数据集。
		- **高并发性**：适合处理高访问负载和大并发量。
		- **灵活性**：数据结构要求不严格，表结构可变，不需要预先定义。
		- **高可用性**：即使部分数据脱机，数据库的其他部分也能继续运行。
3. **劣势**：
		- **数据一致性**：在某些情况下可能不如关系数据库强。
		- **事务处理**：不支持复杂的事务处理。
		- **查询功能**：查询功能相对较弱，缺乏统一的查询语法。
		- **数据建模**：数据建模不如关系数据库直观和严格。
4. **应用场景**：
		- **大数据处理**：适合处理非结构化或半结构化的大型数据集。
		- **Web 应用程序**：能够快速扩展以满足现代 Web 应用的需求。
		- **高访问负载**：如内容缓存和日志系统。

NoSQL 数据库因其卓越的性能和易用性，在云、大数据和移动应用不断发展的时代备受青睐。

NoSQL 数据库的概念与考试方向主要涉及以下几个方面：

1. **键值数据库**：使用简单的键值方法来存储数据。键作为唯一标识符，值可以是任何类型的对象。使用键值对存储数据，查找速度快，但数据无结构化。键值对存储，通常使用哈希表实现。
2. **列存储数据库**：将同一个数据列的各个值存放在一起。适用于大数据量查询。以列簇式存储，适合大数据量查询，但功能相对局限。
3. **文档型数据库**：以文档为单位存储和管理数据，通常使用 JSON、BSON 或 XML 格式。存储结构化文档，数据结构要求不严格，但查询性能不高。键值对，值为结构化数据。
4. **图形数据库**：专门用于存储和查询图结构数据，包括节点和节点之间的关系。专注于构建关系图谱，利用图结构算法，但计算量大且不易分布式。图结构，包括节点和边。

| 数据库类型   | 优点                         | 缺点                                        | 适用场景                       | 典型产品         |
| ------------ | ---------------------------- | ------------------------------------------- | ------------------------------ | ---------------- |
| 键值数据库   | 查找速度快、高可分区性       | 数据无结构化,通常只被当作字符串或二进制数据 | 内容缓存、日志系统             | Redis            |
| 列存储数据库 | 查找速度快、可扩展性强       | 功能相对局限                                | 分布式文件系统、物联网数据存储 | Cassandra、HBase |
| 文档型数据库 | 数据结构要求不严格、灵活性高 | 查询性能不高、缺乏统一的查询语法            | Web 应用、内容管理系统          | MongoDB          |
| 图形数据库   | 高效处理关系丰富的数据       | 计算量大、不易分布式                        | 社交网络、知识图谱             | Neo4J、InfoGrid  |
